<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learning Rust With Entirely Too Many Linked Lists</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learning Rust With Entirely Too Many Linked Lists">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="first.html"><strong aria-hidden="true">2.</strong> A Bad Stack</a></li><li><ol class="section"><li><a href="first-layout.html"><strong aria-hidden="true">2.1.</strong> Layout</a></li><li><a href="first-new.html"><strong aria-hidden="true">2.2.</strong> New</a></li><li><a href="first-ownership.html"><strong aria-hidden="true">2.3.</strong> Ownership 101</a></li><li><a href="first-push.html"><strong aria-hidden="true">2.4.</strong> Push</a></li><li><a href="first-pop.html"><strong aria-hidden="true">2.5.</strong> Pop</a></li><li><a href="first-test.html"><strong aria-hidden="true">2.6.</strong> Testing</a></li><li><a href="first-drop.html"><strong aria-hidden="true">2.7.</strong> Drop</a></li><li><a href="first-final.html"><strong aria-hidden="true">2.8.</strong> Final Code</a></li></ol></li><li><a href="second.html"><strong aria-hidden="true">3.</strong> An Ok Stack</a></li><li><ol class="section"><li><a href="second-option.html"><strong aria-hidden="true">3.1.</strong> Option</a></li><li><a href="second-generic.html"><strong aria-hidden="true">3.2.</strong> Generic</a></li><li><a href="second-peek.html"><strong aria-hidden="true">3.3.</strong> Peek</a></li><li><a href="second-into-iter.html"><strong aria-hidden="true">3.4.</strong> IntoIter</a></li><li><a href="second-iter.html"><strong aria-hidden="true">3.5.</strong> Iter</a></li><li><a href="second-iter-mut.html"><strong aria-hidden="true">3.6.</strong> IterMut</a></li><li><a href="second-final.html"><strong aria-hidden="true">3.7.</strong> Final Code</a></li></ol></li><li><a href="third.html"><strong aria-hidden="true">4.</strong> A Persistent Stack</a></li><li><ol class="section"><li><a href="third-layout.html"><strong aria-hidden="true">4.1.</strong> Layout</a></li><li><a href="third-basics.html"><strong aria-hidden="true">4.2.</strong> Basics</a></li><li><a href="third-drop.html"><strong aria-hidden="true">4.3.</strong> Drop</a></li><li><a href="third-arc.html"><strong aria-hidden="true">4.4.</strong> Arc</a></li><li><a href="third-final.html"><strong aria-hidden="true">4.5.</strong> Final Code</a></li></ol></li><li><a href="fourth.html"><strong aria-hidden="true">5.</strong> A Bad Safe Deque</a></li><li><ol class="section"><li><a href="fourth-layout.html"><strong aria-hidden="true">5.1.</strong> Layout</a></li><li><a href="fourth-building.html"><strong aria-hidden="true">5.2.</strong> Building</a></li><li><a href="fourth-breaking.html"><strong aria-hidden="true">5.3.</strong> Breaking</a></li><li><a href="fourth-peek.html"><strong aria-hidden="true">5.4.</strong> Peek</a></li><li><a href="fourth-symmetry.html"><strong aria-hidden="true">5.5.</strong> Symmetric Cases</a></li><li><a href="fourth-iteration.html"><strong aria-hidden="true">5.6.</strong> Iteration</a></li><li><a href="fourth-final.html"><strong aria-hidden="true">5.7.</strong> Final Code</a></li></ol></li><li><a href="fifth.html"><strong aria-hidden="true">6.</strong> An Unsafe Queue</a></li><li><ol class="section"><li><a href="fifth-layout.html"><strong aria-hidden="true">6.1.</strong> Layout</a></li><li><a href="fifth-unsafe.html"><strong aria-hidden="true">6.2.</strong> Unsafe</a></li><li><a href="fifth-basics.html"><strong aria-hidden="true">6.3.</strong> Basics</a></li><li><a href="fifth-extras.html"><strong aria-hidden="true">6.4.</strong> Extras</a></li><li><a href="fifth-final.html"><strong aria-hidden="true">6.5.</strong> Final Code</a></li></ol></li><li><a href="sixth.html"><strong aria-hidden="true">7.</strong> An Ok Unsafe Deque</a></li><li><a href="infinity.html"><strong aria-hidden="true">8.</strong> A Bunch of Silly Lists</a></li><li><ol class="section"><li><a href="infinity-double-single.html"><strong aria-hidden="true">8.1.</strong> The Double Single</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Learning Rust With Entirely Too Many Linked Lists</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#learning-rust-with-entirely-too-many-linked-lists" id="learning-rust-with-entirely-too-many-linked-lists"><h1>Learning Rust With Entirely Too Many Linked Lists</h1></a>
<p>Got any issues or want to check out all the final code at once?
<a href="https://github.com/Gankro/too-many-lists">Everything's on Github!</a></p>
<p>I fairly frequently get asked how to implement a linked list in Rust. The
answer honestly depends on what your requirements are, and it's obviously not
super easy to answer the question on the spot. As such I've decided to write
this book to comprehensively answer the question once and for all.</p>
<p>In this series I will teach you basic and advanced Rust programming
entirely by having you implement 6 linked lists. In doing so, you should
learn:</p>
<ul>
<li>The following pointer types: <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>*const</code>, <code>*mut</code></li>
<li>Ownership, borrowing, inherited mutability, interior mutability, Copy</li>
<li>All The Keywords: struct, enum, fn, pub, impl, use, ...</li>
<li>Pattern matching, generics, destructors</li>
<li>Testing</li>
<li>Basic Unsafe Rust</li>
</ul>
<p>Yes, linked lists are so truly awful that you deal with all of these concepts in
making them real.</p>
<p>Everything's in the sidebar (may be collapsed on mobile), but for quick
reference, here's what we're going to be making:</p>
<ol>
<li><a href="first.html">A Bad Singly Linked Stack</a></li>
<li><a href="second.html">An Ok Singly Linked Stack</a></li>
<li><a href="third.html">A Persistent Singly Linked Stack</a></li>
<li><a href="fourth.html">A Bad But Safe Doubly Linked Deque</a></li>
<li><a href="fifth.html">An Unsafe Singly Linked Queue</a></li>
<li><a href="sixth.html">TODO: An Ok Unsafe Doubly Linked Deque</a></li>
<li><a href="infinity.html">Bonus: A Bunch of Silly Lists</a></li>
</ol>
<p>Just so we're all the same page, I'll be writing out all the commands that I
feed into my terminal. I'll also be using Rust's standard package manager, Cargo,
to develop the project. Cargo isn't necessary to write a Rust program, but it's
<em>so much</em> better than using rustc directly. If you just want to futz around you
can also run some simple programs in the browser via https://play.rust-lang.org/.</p>
<p>Let's get started and make our project:</p>
<pre><code class="language-text">&gt; cargo new --lib lists
&gt; cd lists
</code></pre>
<p>We'll put each list in a separate file so that we don't lose any of our work.</p>
<p>It should be noted that the <em>authentic</em> Rust learning experience involves
writing code, having the compiler scream at you, and trying to figure out
what the heck that means. I will be carefully ensuring that this occurs as
frequently as possible. Learning to read and understand Rust's generally
excellent compiler errors and documentation is <em>incredibly</em> important to
being a productive Rust programmer.</p>
<p>Although actually that's a lie. In writing this I encountered <em>way</em> more
compiler errors than I show. In particular, in the later chapters I won't be
showing a lot of the random &quot;I typed (read: copy-pasted) bad&quot; errors that you
expect to encounter in every language. This is a <em>guided tour</em> of having the
compiler scream at us.</p>
<p>We're going to be going pretty slow, and I'm honestly not going to be very
serious pretty much the entire time. I think programming should be fun, dang it!
If you're the type of person who wants maximally information-dense, serious, and
formal content, this book is not for you. Nothing I will ever make is for you.
You are wrong.</p>
<a class="header" href="#an-obligatory-public-service-announcement" id="an-obligatory-public-service-announcement"><h1>An Obligatory Public Service Announcement</h1></a>
<p>Just so we're totally 100% clear: I hate linked lists. With
a passion. Linked lists are terrible data structures. Now of course there's
several great use cases for a linked list:</p>
<ul>
<li>You want to do <em>a lot</em> of splitting or merging of big lists. <em>A lot</em>.</li>
<li>You're doing some awesome lock-free concurrent thing.</li>
<li>You're writing a kernel/embedded thing and want to use an intrusive list.</li>
<li>You're using a pure functional language and the limited semantics and absence
of mutation makes linked lists easier to work with.</li>
<li>... and more!</li>
</ul>
<p>But all of these cases are <em>super rare</em> for anyone writing a Rust program. 99%
of the time you should just use a Vec (array stack), and 99% of the other 1%
of the time you should be using a VecDeque (array deque). These are blatantly
superior data structures for most workloads due to less frequent allocation,
lower memory overhead, true random access, and cache locality.</p>
<p>Linked lists are as <em>niche</em> and <em>vague</em> of a data structure as a trie. Few would
balk at me claiming a trie is a niche structure that your average programmer
could happily never learn in an entire productive career -- and yet linked lists
have some bizarre celebrity status. We teach every undergrad how to write a
linked list. It's the only niche collection
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">I couldn't kill from std::collections</a>. It's
<a href="http://en.cppreference.com/w/cpp/container/list"><em>the</em> list in C++</a>!</p>
<p>We should all as a community say <em>no</em> to linked lists as a &quot;standard&quot; data
structure. It's a fine data structure with several great use cases, but those
use cases are <em>exceptional</em>, not common.</p>
<p>Several people apparently read the first paragraph of this PSA and then stop
reading. Like, literally they'll try to rebut my argument by listing one of the
things in my list of <em>great use cases</em>. The thing right after the first
paragraph!</p>
<p>Just so I can link directly to a detailed argument, here are several attempts
at counter-arguments I have seen, and my response to them. Feel free to skip
to <a href="#take-a-breath">the end</a> if you just want to learn some Rust!</p>
<a class="header" href="#performance-doesnt-always-matter" id="performance-doesnt-always-matter"><h2>Performance doesn't always matter</h2></a>
<p>Yes! Maybe your application is I/O-bound or the code in question is in some
cold case that just doesn't matter. But this isn't even an argument for using
a linked list. This is an argument for using <em>whatever at all</em>. Why settle for
a linked list? Use a linked hash map!</p>
<p>If performance doesn't matter, then it's <em>surely</em> fine to apply the natural
default of an array.</p>
<a class="header" href="#they-have-o1-split-append-insert-remove-if-you-have-a-pointer-there" id="they-have-o1-split-append-insert-remove-if-you-have-a-pointer-there"><h2>They have O(1) split-append-insert-remove if you have a pointer there</h2></a>
<p>Yep! Although as <a href="https://www.youtube.com/watch?v=YQs6IC-vgmo">Bjarne Stroustrup notes</a> <em>this doesn't actually
matter</em> if the time it takes to get that pointer completely dwarfs the
time it would take to just copy over all the elements in an array (which is
really quite fast).</p>
<p>Unless you have a workload that is heavily dominated by splitting and merging
costs, the penalty <em>every other</em> operation takes due to caching effects and code
complexity will eliminate any theoretical gains.</p>
<p><em>But yes, if you're profiling your application to spend a lot of time in
splitting and merging, you may have gains in a linked list</em>.</p>
<a class="header" href="#i-cant-afford-amortization" id="i-cant-afford-amortization"><h2>I can't afford amortization</h2></a>
<p>You've already entered a pretty niche space -- most can afford amortization.
Still, arrays are amortized <em>in the worst case</em>. Just because you're using an
array, doesn't mean you have amortized costs. If you can predict how many
elements you're going to store (or even have an upper-bound), you can
pre-reserve all the space you need. In my experience it's <em>very</em> common to be
able to predict how many elements you'll need. In Rust in particular, all
iterators provide a <code>size_hint</code> for exactly this case.</p>
<p>Then <code>push</code> and <code>pop</code> will be truly O(1) operations. And they're going to be
<em>considerably</em> faster than <code>push</code> and <code>pop</code> on linked list. You do a pointer
offset, write the bytes, and increment an integer. No need to go to any kind of
allocator.</p>
<p>How's that for low latency?</p>
<p><em>But yes, if you can't predict your load, there are worst-case
latency savings to be had!</em></p>
<a class="header" href="#linked-lists-waste-less-space" id="linked-lists-waste-less-space"><h2>Linked lists waste less space</h2></a>
<p>Well, this is complicated. A &quot;standard&quot; array resizing strategy is to grow
or shrink so that at most half the array is empty. This is indeed a lot of
wasted space. Especially in Rust, we don't automatically shrink collections
(it's a waste if you're just going to fill it back up again), so the wastage
can approach infinity!</p>
<p>But this is a worst-case scenario. In the best-case, an array stack only has
three pointers of overhead for the entire array. Basically no overhead.</p>
<p>Linked lists on the other hand unconditionally waste space per element.
A singly-linked lists wastes one pointer while a doubly-linked list wastes
two. Unlike an array, the relative wasteage is proportional to the size of
the element. If you have <em>huge</em> elements this approaches 0 waste. If you have
tiny elements (say, bytes), then this can be as much as 16x memory overhead
(8x on 32-bit)!</p>
<p>Actually, it's more like 23x (11x on 32-bit) because padding will be added
to the byte to align the whole node's size to a pointer.</p>
<p>This is also assuming the best-case for your allocator: that allocating and
deallocating nodes is being done densely and you're not losing memory to
fragmentation.</p>
<p><em>But yes, if you have huge elements, can't predict your load, and have a
decent allocator, there are memory savings to be had!</em></p>
<a class="header" href="#i-use-linked-lists-all-the-time-in-functional-language" id="i-use-linked-lists-all-the-time-in-functional-language"><h2>I use linked lists all the time in &lt;functional language&gt;</h2></a>
<p>Great! Linked lists are super elegant to use in functional languages
because you can manipulate them without any mutation, can describe them
recursively, and also work with infinite lists due to the magic of laziness.</p>
<p>Specifically, linked lists are nice because they represent an iteration without
the need for any mutable state. The next step is just visiting the next sublist.</p>
<p>However it should be noted that Rust can pattern match on arrays and talk
about sub-arrays <a href="https://doc.rust-lang.org/book/slice-patterns.html">using slices</a>! It's actually even more expressive
than a functional list in some regards because you can talk about the last
element or even &quot;the array without the first and last two elements&quot; or
whatever other crazy thing you want.</p>
<p>It is true that you can't <em>build</em> a list using slices. You can only tear
them apart.</p>
<p>For laziness we instead have <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterators</a>. These can be infinite and you
can map, filter, reverse, and concatenate them just like a functional list,
and it will all be done just as lazily. No surprise here: slices can also be
coerced to an iterator.</p>
<p><em>But yes, if you're limited to immutable semantics, linked lists can be very
nice</em>.</p>
<p>Note that I'm not saying that functional programming is necessarily weak or
bad. However it <em>is</em> fundamentally semantically limited: you're largely only
allowed to talk about how things <em>are</em>, and not how they should be <em>done</em>. This
is actually a <em>feature</em>, because it enables the compiler to do tons of <a href="https://wiki.haskell.org/GHC_optimisations#Fusion">exotic
transformations</a> and potentially figure out the <em>best</em> way to do things
without you having to worry about it. However this comes at the cost of being
<em>able</em> to worry about it. There are usually escape hatches, but at some limit
you're just writing procedural code again.</p>
<p>Even in functional languages, you should endeavour to use the appropriate data
structure for the job when you actually need a data structure. Yes, singly
linked lists are your primary tool for control flow, but they're a really poor
way to actually store a bunch of data and query it.</p>
<a class="header" href="#linked-lists-are-great-for-building-concurrent-data-structures" id="linked-lists-are-great-for-building-concurrent-data-structures"><h2>Linked lists are great for building concurrent data structures!</h2></a>
<p>Yes! Although writing a concurrent data structure is really a whole different
beast, and isn't something that should be taken lightly. Certainly not something
many people will even <em>consider</em> doing. Once one's been written, you're also not
really choosing to use a linked list. You're choosing to use an MPSC queue or
whatever. The implementation strategy is pretty far removed in this case!</p>
<p><em>But yes, linked lists are the defacto heroes of the dark world of lock-free
concurrency.</em></p>
<a class="header" href="#mumble-mumble-kernel-embedded-something-something-intrusive" id="mumble-mumble-kernel-embedded-something-something-intrusive"><h2>Mumble mumble kernel embedded something something intrusive.</h2></a>
<p>It's niche. You're talking about a situation where you're not even using
your language's <em>runtime</em>. Is that not a red flag that you're doing something
strange?</p>
<p>It's also wildly unsafe.</p>
<p><em>But sure. Build your awesome zero-allocation lists on the stack.</em></p>
<a class="header" href="#iterators-dont-get-invalidated-by-unrelated-insertionsremovals" id="iterators-dont-get-invalidated-by-unrelated-insertionsremovals"><h2>Iterators don't get invalidated by unrelated insertions/removals</h2></a>
<p>That's a delicate dance you're playing. Especially if you don't have
a garbage collector. I might argue that your control flow and ownership
patterns are probably a bit too tangled, depending on the details.</p>
<p><em>But yes, you can do some really cool crazy stuff with cursors.</em></p>
<a class="header" href="#theyre-simple-and-great-for-teaching" id="theyre-simple-and-great-for-teaching"><h2>They're simple and great for teaching!</h2></a>
<p>Well, yeah. You're reading a book dedicated to that premise.
Well, singly linked lists are pretty simple. Doubly linked lists
can get kinda gnarly, as we'll see.</p>
<a class="header" href="#take-a-breath" id="take-a-breath"><h1>Take a Breath</h1></a>
<p>Ok. That's out of the way. Let's write a bajillion linked lists.</p>
<a class="header" href="#a-bad-singly-linked-stack" id="a-bad-singly-linked-stack"><h1>A Bad Singly-Linked Stack</h1></a>
<p>This one's gonna be <em>by far</em> the longest, as we need to introduce basically
all of Rust, and are gonna build up some things &quot;the hard way&quot; to better
understand the language.</p>
<p>We'll put our first list in <code>src/first.rs</code>. We need to tell Rust that <code>first.rs</code> is
something that our lib uses. All that requires is that we put this at the top of
<code>src/lib.rs</code> (which Cargo made for us):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// in lib.rs
pub mod first;
#}</code></pre></pre>
<a class="header" href="#basic-data-layout" id="basic-data-layout"><h1>Basic Data Layout</h1></a>
<p>Alright, so what's a linked list? Well basically, it's a bunch of pieces of data
on the heap (shhh Linux Kernel!) that point to each other in sequence. Linked
lists are something procedural programmers shouldn't touch with a 10-foot pole,
and what functional programmers use for everything. It seems fair, then, that we
should ask functional programmers for the definition of a linked list. They will
probably give you something like the following definition:</p>
<pre><code class="language-haskell">List a = Empty | Elem a (List a)
</code></pre>
<p>Which reads approximately as &quot;A List is either Empty or an Element followed by a
List&quot;. This is a recursive definition expressed as a <em>sum type</em>, which is a
fancy name for &quot;a type that can have different values which may be different
types&quot;. Rust calls sum types <code>enum</code>s! If you're coming from a C-like language,
this is exactly the enum you know and love, but on meth. So let's transcribe
this functional definition into Rust!</p>
<p>For now we'll avoid generics to keep things simple. We'll only support
storing signed 32-bit integers:</p>
<pre><code class="language-rust ignore">// in first.rs

// pub says we want people outside this module to be able to use List
pub enum List {
    Empty,
    Elem(i32, List),
}
</code></pre>
<p><em>phew</em>, I'm swamped. Let's just go ahead and compile that:</p>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/lists)
src/first.rs:1:1: 4:2 error: recursive type `first::List` has infinite size [E0072]
src/first.rs:1 pub enum List {
              ^
src/first.rs:1:1: 4:2 help: run `rustc --explain E0072` to see a detailed explanation
src/first.rs:1:1: 4:2 help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `first::List` representable
error: aborting due to previous error
error: Could not compile `list`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Noooooooo!!!! Functional programmers tricked us! That made us do something
<em>illegal</em>! This is entrapment!</p>
<p>...</p>
<p>I'm ok now. Are you ok now? If we actually check out the error message (instead
of getting ready to flee the country, as *ahem* <em>some</em> of us did), we can see
that rustc is actually telling us exactly how to solve this problem:</p>
<blockquote>
<p>insert indirection (e.g., a <code>Box</code>, <code>Rc</code>, or <code>&amp;</code>) at some point to make <code>first::List</code> representable</p>
</blockquote>
<p>Alright, <code>box</code>. What's that? Let's google <code>rust box</code>...</p>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">std::boxed::Box - Rust</a></p>
</blockquote>
<p>Lesse here...</p>
<blockquote>
<p><code>pub struct Box&lt;T&gt;(_);</code></p>
<p>A pointer type for heap allocation.
See the <a href="https://doc.rust-lang.org/std/boxed/">module-level documentation</a> for more.</p>
</blockquote>
<p><em>clicks link</em></p>
<blockquote>
<p><code>Box&lt;T&gt;</code>, casually referred to as a 'box', provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope.</p>
<p>Examples</p>
<p>Creating a box:</p>
<p><code>let x = Box::new(5);</code></p>
<p>Creating a recursive data structure:</p>
</blockquote>
<pre><code>#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}
</code></pre>
<blockquote>
</blockquote>
<pre><code>fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{:?}&quot;, list);
}
</code></pre>
<blockquote>
<p>This will print <code>Cons(1, Box(Cons(2, Box(Nil))))</code>.</p>
<p>Recursive structures must be boxed, because if the definition of Cons looked like this:</p>
<p><code>Cons(T, List&lt;T&gt;),</code></p>
<p>It wouldn't work. This is because the size of a List depends on how many elements are in the list, and so we don't know how much memory to allocate for a Cons. By introducing a Box, which has a defined size, we know how big Cons needs to be.</p>
</blockquote>
<p>Wow, uh. That is perhaps the most relevant and helpful documentation I have ever seen. Literally the first thing in the documentation is <em>exactly what we're trying to write, why it didn't work, and how to fix it</em>. Dang, yo. Docs.</p>
<p>Ok, let's do that:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub enum List {
    Empty,
    Elem(i32, Box&lt;List&gt;),
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/lists)
</code></pre>
<p>Hey it built!</p>
<p>...but this is actually a really stupid definition of a List, for a few reasons.</p>
<p>Consider a list with two elements:</p>
<pre><code class="language-text">[] = Stack
() = Heap

[Elem A, ptr] -&gt; (Elem B, ptr) -&gt; (Empty *junk*)
</code></pre>
<p>There are two key issues:</p>
<ul>
<li>We're allocating a node that just says &quot;I'm not actually a Node&quot;</li>
<li>One of our nodes isn't allocated at all.</li>
</ul>
<p>On the surface, these two seem to cancel each-other out. We allocate an
extra node, but one of our nodes doesn't need to be allocated at all.
However, consider the following potential layout for our list:</p>
<pre><code class="language-text">[ptr] -&gt; (Elem A, ptr) -&gt; (Elem B, *null*)
</code></pre>
<p>In this layout we now unconditionally heap allocate our nodes. The
key difference is the absence of the <em>junk</em> from our first layout. What is
this junk? To understand that, we'll need to look at how an enum is laid out
in memory.</p>
<p>In general, if we have an enum like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Foo {
    D1(T1),
    D2(T2),
    ...
    Dn(Tn),
}
#}</code></pre></pre>
<p>A Foo will need to store some integer to indicate which <em>variant</em> of the enum it
represents (<code>D1</code>, <code>D2</code>, .. <code>Dn</code>). This is the <em>tag</em> of the enum. It will also
need enough space to store the <em>largest</em> of <code>T1</code>, <code>T2</code>, .. <code>Tn</code> (plus some extra
space to satisfy alignment requirements).</p>
<p>The big takeaway here is that even though <code>Empty</code> is a single bit of
information, it necessarily consumes enough space for a pointer and an element,
because it has to be ready to become an <code>Elem</code> at any time. Therefore the first
layout heap allocates an extra element that's just full of junk, consuming a
bit more space than the second layout.</p>
<p>One of our nodes not being allocated at all is also, perhaps surprisingly,
<em>worse</em> than always allocating it. This is because it gives us a <em>non-uniform</em>
node layout. This doesn't have much of an appreciable effect on pushing and
popping nodes, but it does have an effect on splitting and merging lists.</p>
<p>Consider splitting a list in both layouts:</p>
<pre><code class="language-text">layout 1:

[Elem A, ptr] -&gt; (Elem B, ptr) -&gt; (Elem C, ptr) -&gt; (Empty *junk*)

split off C:

[Elem A, ptr] -&gt; (Elem B, ptr) -&gt; (Empty *junk*)
[Elem C, ptr] -&gt; (Empty *junk*)
</code></pre>
<pre><code class="language-text">layout 2:

[ptr] -&gt; (Elem A, ptr) -&gt; (Elem B, ptr) -&gt; (Elem C, *null*)

split off C:

[ptr] -&gt; (Elem A, ptr) -&gt; (Elem B, *null*)
[ptr] -&gt; (Elem C, *null*)
</code></pre>
<p>Layout 2's split involves just copying B's pointer to the stack and nulling
the old value out. Layout 1 ultimately does the same thing, but also has to
copy C from the heap to the stack. Merging is the same process in reverse.</p>
<p>One of the few nice things about a linked list is that you can construct the
element in the node itself, and then freely shuffle it around lists without
ever moving it. You just fiddle with pointers and stuff gets &quot;moved&quot;. Layout 1
trashes this property.</p>
<p>Alright, I'm reasonably convinced Layout 1 is bad. How do we rewrite our List?
Well, we could do something like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub enum List {
    Empty,
    ElemThenEmpty(i32),
    ElemThenNotEmpty(i32, Box&lt;List&gt;),
}
#}</code></pre></pre>
<p>Hopefully this seems like an even worse idea to you. For one, this really
complicates our logic. In particular, there is now a completely invalid state:
<code>ElemThenNotEmpty(0, Box(Empty))</code>. It also <em>still</em> suffers from non-uniformly
allocating our elements.</p>
<p>However it does have <em>one</em> interesting property: it totally avoids allocating
the Empty case, reducing the total number of heap allocations by 1. Unfortunately,
in doing so it manages to waste <em>even more space</em>! This is because the previous
layout took advantage of the <em>null pointer optimization</em>.</p>
<p>We previously saw that every enum has to store a <em>tag</em> to specify which variant
of the enum its bits represent. However, if we have a special kind of enum:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Foo {
    A,
    B(ContainsANonNullPtr),
}
#}</code></pre></pre>
<p>the null pointer optimization kicks in, which <em>eliminates the space needed for
the tag</em>. If the variant is A, the whole enum is set to all <code>0</code>'s. Otherwise,
the variant is B. This works because B can never be all <code>0</code>'s, since it contains
a non-zero pointer. Slick!</p>
<p>Can you think of other enums and types that could do this kind of optimization?
There's actually a lot! This is why Rust leaves enum layout totally unspecified.
Sadly the null pointer optimization is the only one implemented today -- though
it's pretty important! It means <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>Vec</code>, and
several other important types in Rust have no overhead when put in an <code>Option</code>!
(We'll get to most of these in due time).</p>
<p>So how do we avoid the extra junk, uniformly allocate, <em>and</em> get that sweet
null-pointer optimization? We need to better separate out the idea of having an
element from allocating another list. To do this, we have to think a little more
C-like: structs!</p>
<p>While enums let us declare a type that can contain <em>one</em> of several values,
structs let us declare a type that contains <em>many</em> values at once. Let's break
our List into two types: A List, and a Node.</p>
<p>As before, a List is either Empty or has an element followed by another List.
However by representing the &quot;has an element followed by another List&quot; case by an
entirely separate type, we can hoist the Box to be in a more optimal position:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Node {
    elem: i32,
    next: List,
}

pub enum List {
    Empty,
    More(Box&lt;Node&gt;),
}
#}</code></pre></pre>
<p>Let's check our priorities:</p>
<ul>
<li>Tail of a list never allocates extra junk: check!</li>
<li><code>enum</code> is in delicious null-pointer-optimized form: check!</li>
<li>All elements are uniformly allocated: check!</li>
</ul>
<p>Alright! We actually just constructed exactly the layout that we used to
demonstrate that our first layout (as suggested by the official Rust
documentation) was problematic.</p>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/lists)
src/first.rs:8:11: 8:18 error: private type in exported type signature
src/first.rs:8    More(Box&lt;Node&gt;),
                           ^~~~~~~
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>:(</p>
<p>Rust is mad at us again. We marked the <code>List</code> as public (because we want people
to be able to use it), but not the <code>Node</code>. The problem is that the internals of
an <code>enum</code> are totally public, and we're not allowed to publicly talk about
private types. We could make all of <code>Node</code> totally public, but generally in Rust
we favour keeping implementation details private. Let's make <code>List</code> a struct, so
that we can hide the implementation details:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}
#}</code></pre></pre>
<p>Because <code>List</code> is a struct with a single field, its size is the same as that
field. Yay zero-cost abstractions!</p>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/lists)
src/first.rs:2:2: 2:15 warning: struct field is never used: `head`, #[warn(dead_code)] on by default
src/first.rs:2    head: Link,
                  ^~~~~~~~~~~~~
src/first.rs:6:2: 6:7 warning: variant is never used: `Empty`, #[warn(dead_code)] on by default
src/first.rs:6    Empty,
                  ^~~~~
src/first.rs:7:2: 7:20 warning: variant is never used: `More`, #[warn(dead_code)] on by default
src/first.rs:7    More(Box&lt;Node&gt;),
                  ^~~~~~~~~~~~~~~~~~
src/first.rs:11:2: 11:9 warning: struct field is never used: `elem`, #[warn(dead_code)] on by default
src/first.rs:11   elem: i32,
                  ^~~~~~~
src/first.rs:12:2: 12:15 warning: struct field is never used: `next`, #[warn(dead_code)] on by default
src/first.rs:12   next: Link,
                  ^~~~~~~~~~~~~
</code></pre>
<p>Alright, that compiled! Rust is pretty mad, because as far as it can tell,
everything we've written is totally useless: we never use <code>head</code>, and no one who
uses our library can either since it's private. Transitively, that means Link
and Node are useless too. So let's solve that! Let's implement some code for our
List!</p>
<a class="header" href="#new" id="new"><h1>New</h1></a>
<p>To associate actual code with a type, we use <code>impl</code> blocks:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl List {
    // TODO, make code happen
}
#}</code></pre></pre>
<p>Now we just need to figure out how to actually write code. In Rust we declare
a function like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(arg1: Type1, arg2: Type2) -&gt; ReturnType {
    // body
}
#}</code></pre></pre>
<p>The first thing we want is a way to <em>construct</em> a list. Since we hide the
implementation details, we need to provide that as a function. The usual way
to do that in Rust is to provide a static method, which is just a
normal function inside an <code>impl</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl List {
    pub fn new() -&gt; Self {
        List { head: Link::Empty }
    }
}
#}</code></pre></pre>
<p>A few notes on this:</p>
<ul>
<li>Self is an alias for &quot;that type I wrote at top next to <code>impl</code>&quot;. Great for
not repeating yourself!</li>
<li>We create an instance of a struct in much the same way we declare it, except
instead of providing the types of its fields, we initialize them with values.</li>
<li>We refer to variants of an enum using <code>::</code>, which is the namespacing operator.</li>
<li>The last expression of a function is implicitly returned.
This makes simple functions a little neater. You can still use <code>return</code>
to return early like other C-like languages.</li>
</ul>
<a class="header" href="#ownership-101" id="ownership-101"><h1>Ownership 101</h1></a>
<p>Now that we can construct a list, it'd be nice to be able to <em>do</em> something
with it. We do that with &quot;normal&quot; (non-static) methods. Methods are a special
case of function in Rust because of  the <code>self</code> argument, which doesn't have
a declared type:</p>
<pre><code class="language-rust ignore">fn foo(self, arg2: Type2) -&gt; ReturnType {
    // body
}
</code></pre>
<p>There are 3 primary forms that self can take: <code>self</code>, <code>&amp;mut self</code>, and <code>&amp;self</code>.
These 3 forms represent the three primary forms of ownership in Rust:</p>
<ul>
<li><code>self</code> - Value</li>
<li><code>&amp;mut self</code> - mutable reference</li>
<li><code>&amp;self</code> - shared reference</li>
</ul>
<p>A value represents <em>true</em> ownership. You can do whatever you want with a value:
move it, destroy it, mutate it, or loan it out via a reference. When you pass
something by value, it's <em>moved</em> to the new location. The new location now
owns the value, and the old location can no longer access it. For this reason
most methods don't want <code>self</code> -- it would be pretty lame if trying to work with
a list made it go away!</p>
<p>A mutable reference represents temporary <em>exclusive access</em> to a value that you
don't own. You're allowed to do absolutely anything you want to a value you
have a mutable reference to as long as when your loan expires, wherever you
loaned it from still sees a valid value. This means you can actually completely
overwrite the value. A really useful special case of this is <em>swapping</em> a value
out for another, which we'll be using a lot. The only thing you can't do with an
<code>&amp;mut</code> is move the value out with no replacement. <code>&amp;mut self</code> is great for
methods that want to mutate <code>self</code>.</p>
<p>A shared reference represents temporary <em>shared access</em> to a value that you
don't own. Because you have shared access, you're generally not allowed to
mutate anything. Think of <code>&amp;</code> as putting the value out on display in a museum.
<code>&amp;</code> is great for methods that only want to observe <code>self</code>.</p>
<p>Later we'll see that the rule about mutation can be bypassed in certain cases.
This is why shared references aren't called <em>immutable</em> references. Really,
mutable references could be called <em>unique</em> references, but we've found that
relating ownership to mutability gives the right intuition 99% of the time.</p>
<a class="header" href="#push" id="push"><h1>Push</h1></a>
<p>So let's write pushing a value onto a list. <code>push</code> <em>mutates</em> the list,
so we'll want to take <code>&amp;mut self</code>. We also need to take an i32 to push:</p>
<pre><code class="language-rust ignore">impl List {
    pub fn push(&amp;mut self, elem: i32) {
        // TODO
    }
}
</code></pre>
<p>First things first, we need to make a node to store our element in:</p>
<pre><code class="language-rust ignore">    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: ?????
        };
    }
</code></pre>
<p>What goes <code>next</code>? Well, the entire old list! Can we... just do that?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl List {
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: self.head,
        };
    }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/lists)
src/first.rs:19:10: 19:14 error: cannot move out of borrowed content
src/first.rs:19           next: self.head,
                                ^~~~
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>Nooooope. Rust is telling us the right thing, but it's certainly not obvious
what exactly it means, or what to do about it:</p>
<blockquote>
<p>cannot move out of borrowed content</p>
</blockquote>
<p>We're trying to move the <code>self.head</code> field out to <code>next</code>, but Rust doesn't want
us doing that. This would leave <code>self</code> only partially initialized when we end
the borrow and &quot;give it back&quot; to its rightful owner. As we said before, that's
the <em>one</em> thing you can't do with an <code>&amp;mut</code>: It would be super rude,
and Rust is very polite (it would also be incredibly dangerous, but surely
<em>that</em> isn't why it cares).</p>
<p>What if we put something back? Namely, the node that we're creating:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn push(&amp;mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: self.head,
    });

    self.head = Link::More(new_node);
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/lists)
src/first.rs:19:10: 19:14 error: cannot move out of borrowed content
src/first.rs:19           next: self.head,
                                ^~~~
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>No dice. In principle, this is something Rust could actually accept, but it
won't (for various reasons -- the most serious being exception safety). We need
some way to get the head without Rust noticing that it's gone. For advice, we
turn to infamous Rust Hacker Indiana Jones:</p>
<p><img src="img/indy.gif" alt="Indy Prepares to mem::replace" /></p>
<p>Ah yes, Indy suggests the <code>mem::replace</code> maneuver. This incredibly useful
function lets us steal a value out of a borrow by <em>replacing</em> it with another
value. Let's just pull in <code>std::mem</code> at the top of the file, so that <code>mem</code> is in
local scope:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::mem;
#}</code></pre></pre>
<p>and use it appropriately:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn push(&amp;mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: mem::replace(&amp;mut self.head, Link::Empty),
    });

    self.head = Link::More(new_node);
}
#}</code></pre></pre>
<p>Here we <code>replace</code> self.head temporarily with Link::Empty before replacing it
with the new head of the list. I'm not gonna lie: this is a pretty unfortunate
thing to have to do. Sadly, we must (for now).</p>
<p>But hey, that's <code>push</code> all done! Probably. We should probably test it, honestly.
Right now the easiest way to do that is probably to write <code>pop</code>, and make sure
that it produces the right results.</p>
<a class="header" href="#pop" id="pop"><h1>Pop</h1></a>
<p>Like <code>push</code>, <code>pop</code> wants to mutate the list. However, unlike <code>push</code> we actually
want to return something. However <code>pop</code> also has to deal with a tricky corner
case: what if the list is empty? To represent this case, we use the trusty
<code>Option</code> type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    //TODO
}
#}</code></pre></pre>
<p><code>Option&lt;T&gt;</code> is an enum that represents a value that may exist. It can either be
<code>Some(T)</code> or <code>None</code>. We could make our own enum for this like we did for
Link, but we want our users to be able to understand what the heck our return
type is, and Option is so ubiquitous that <em>everyone</em> knows it. In fact, it's so
fundamental that it's implicitly imported into scope in every file, as well
as its variants <code>Some</code> and <code>None</code> (so we don't have to say <code>Option::None</code>).</p>
<p>The pointy bits on <code>Option&lt;T&gt;</code> indicate that Option is actually <em>generic</em> over
T. That means that you can make an Option for <em>any</em> type!</p>
<p>So uh, we have this <code>Link</code> thing, how do we figure out if it's Empty or has
More? Pattern matching with <code>match</code>!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(node) =&gt; {
            // TODO
        }
    };
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/lists)
src/first.rs:27:2: 36:3 error: not all control paths return a value [E0269]
src/first.rs:27   pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
src/first.rs:28       match self.head {
src/first.rs:29           Link::Empty =&gt; {
src/first.rs:30               // TODO
src/first.rs:31           }
src/first.rs:32           Link::More(node) =&gt; {
              ...
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>Whoops, <code>pop</code> has to return a value, and we're not doing that yet. We <em>could</em>
return <code>None</code>, but in this case it's probably a better idea to return
<code>unimplemented!()</code>, to indicate that we aren't done implementing the function.
<code>unimplemented!()</code> is a macro (<code>!</code> indicates a macro) that panics (basically
just crashes in a controlled manner) the program when we get to it.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(node) =&gt; {
            // TODO
        }
    };
    unimplemented!()
}
#}</code></pre></pre>
<p>Unconditional panics are an example of a <a href="http://doc.rust-lang.org/nightly/book/functions.html#diverging-functions">diverging function</a>.
Diverging functions never return to the caller, so they may be used in places
where a value of any type is expected. Here, <code>unimplemented!()</code> is being
used in place of a value of type <code>Option&lt;T&gt;</code>.</p>
<p>Note also that we don't need to write <code>return</code> in our program. The last
expression (basically line) in a function is implicitly its return value. This
lets us express really simple things a bit more concisely. You can always
explicitly return early with <code>return</code> like any other C-like language.</p>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/lists)
src/first.rs:28:9: 28:13 error: cannot move out of borrowed content
src/first.rs:28       match self.head {
                            ^~~~
src/first.rs:32:15: 32:19 note: attempting to move value to here
src/first.rs:32           Link::More(node) =&gt; {
                                     ^~~~
src/first.rs:32:15: 32:19 help: to prevent the move, use `ref node` or `ref mut node` to capture value by reference
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>Come on Rust, get off our back! As always, Rust is hella mad at us. Thankfully,
this time it's also giving us the full scoop!</p>
<pre><code class="language-text">src/first.rs:17:9: 17:13 error: cannot move out of borrowed content
src/first.rs:17       match self.head {
                            ^~~~
src/first.rs:21:15: 21:19 note: attempting to move value to here
src/first.rs:21           Link::More(node) =&gt; {
                                     ^~~~
</code></pre>
<p>Pattern matches by default move the value they match on, so that's why Rust's
mad.</p>
<pre><code class="language-text">help: to prevent the move, use `ref node` or `ref mut node` to capture value by reference
</code></pre>
<p>to avoid that, we use the <code>ref</code> keyword to indicate that we want to bind the
<code>node</code> subpattern by reference instead. Let's do that:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(ref node) =&gt; {
            // TODO
        }
    };
    unimplemented!()
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/lists)
src/first.rs:13:2: 13:9 warning: struct field is never used: `elem`, #[warn(dead_code)] on by default
src/first.rs:13   elem: i32,
                  ^~~~~~~
src/first.rs:14:2: 14:15 warning: struct field is never used: `next`, #[warn(dead_code)] on by default
src/first.rs:14   next: Link&lt;T&gt;,
                  ^~~~~~~~~~~~~
src/first.rs:32:15: 32:23 warning: unused variable: `node`, #[warn(unused_variables)] on by default
src/first.rs:32           Link::More(ref node) =&gt; {
                                     ^~~~~~~~
</code></pre>
<p>Hooray, compiling again! Now let's figure out that logic. We want to make an
Option, so let's make a variable for that. In the Empty case we need to return
None. In the More case we need to return <code>Some(i32)</code>, and change the head of
the list. So, let's try to do basically that?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    let result;
    match self.head {
        Link::Empty =&gt; {
            result = None;
        }
        Link::More(ref node) =&gt; {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/first.rs:39:29: 39:33 error: cannot move out of borrowed content
src/first.rs:39                 self.head = node.next;
                                            ^~~~
src/first.rs:39:17: 39:38 error: cannot assign to `self.head` because it is borrowed
src/first.rs:39                 self.head = node.next;
                                ^~~~~~~~~~~~~~~~~~~~~
src/first.rs:37:24: 37:32 note: borrow of `self.head` occurs here
src/first.rs:37             Link::More(ref node) =&gt; {
                                       ^~~~~~~~
error: aborting due to 2 previous errors
Could not compile `lists`.
</code></pre>
<p><em>head</em></p>
<p><em>desk</em></p>
<p>Now we have two <em>different</em> errors. First, we're trying to move out of <code>node</code>
when all we have is a shared reference to it. Second, we're trying to mutate
<code>self.head</code> while we've already borrowed it to get the reference to <code>node</code>!</p>
<p>This is a tangled mess.</p>
<p>We should probably step back and think about what we're trying to do. We want
to:</p>
<ul>
<li>Check if the list is empty.</li>
<li>If it's empty, just return None</li>
<li>If it's <em>not</em> empty
<ul>
<li>remove the head of the list</li>
<li>remove its <code>elem</code></li>
<li>replace the lists head with its <code>next</code></li>
<li>return <code>Some(elem)</code></li>
</ul>
</li>
</ul>
<p>The key insight is we want to <em>remove</em> things, which means we want to get the
head of the list <em>by value</em>. We certainly can't do that through the shared
reference we get through <code>ref node</code>. We also &quot;only&quot; have a mutable reference,
so the only way we can move stuff is to <em>replace it</em>. Looks like we're doing
the Empty dance again! Let's try that:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    let result;
    match mem::replace(&amp;mut self.head, Link::Empty) {
        Link::Empty =&gt; {
            result = None;
        }
        Link::More(node) =&gt; {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
#}</code></pre></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
</code></pre>
<p>O M G</p>
<p>It compiled without <em>any</em> warnings!!!!!</p>
<p>Actually I'm going to apply my own personal lint here: we made this <code>result</code>
value to return, but actually we didn't need to do that at all! Just as a
function evaluated to its last expression, every block also evaluates to
its last expression. Normally we supress this behaviour with semi-colons,
which instead makes the block evaluate to the empty tuple, <code>()</code>. This is
actually the value that functions which don't declare a return value -- like
<code>push</code> -- return.</p>
<p>So instead, we can write <code>pop</code> as:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match mem::replace(&amp;mut self.head, Link::Empty) {
        Link::Empty =&gt; None,
        Link::More(node) =&gt; {
            self.head = node.next;
            Some(node.elem)
        }
    }
}
#}</code></pre></pre>
<p>Which is a bit more concise and idiomatic. Note that the Link::Empty branch
completely lost its braces, because we only have one expression to
evaluate. Just a nice shorthand for simple cases.</p>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/first.rs:36:22: 36:31 error: use of moved value: `node` [E0382]
src/first.rs:36                 Some(node.elem)
                                     ^~~~~~~~~
src/first.rs:35:29: 35:38 note: `node` moved here (through moving `node.next`) because it has type `first::Link`, which is non-copyable
src/first.rs:35                 self.head = node.next;
                                            ^~~~~~~~~
error: aborting due to previous error
</code></pre>
<p>WHAT. COME ON.</p>
<p>Why the heck did our code stop working?!</p>
<p>It turns out we accidentally got lucky with the previous code. We have just had
our first run in with the magic of Copy. When we introduced <a href="first-ownership.html">ownership</a> we
said that when you move stuff, you can't use it anymore. For some types, this
makes perfect sense. Our good friend Box manages an allocation on the heap for
us, and we certainly don't want two pieces of code to think that they need to
free its memory.</p>
<p>However for other types this is <em>butts</em>. Integers have no
ownership semantics; they're just meaningless numbers! This is why integers are
marked as Copy. Copy types are known to be perfectly copyable by a bitwise copy.
As such, they have a super power: when moved, the old value <em>is</em> still usable.
As a consequence, you can even move a Copy type out of a reference without
replacement!</p>
<p>All numeric primitives in rust (i32, u64, bool, f32, char, etc...) are Copy.
Also, shared references are Copy, which is super useful! You can also declare
any user-defined type to be Copy as well, as long as all its components are
Copy.</p>
<p>Anyway, back to the code: what went wrong? In our first iteration, we were
actually <em>copying</em> the i32 <code>elem</code> when we assigned to result, so the node was
left unscathed for the next operation. Now we're <em>moving</em> the <code>next</code> value
(which isn't Copy), and that consumes the whole Box before we can get to <code>elem</code>.</p>
<p>Now, we could just rearrange again to get <code>elem</code> first, but we're only using
i32 as a placeholder for <em>some</em> data. Later we'll want to work with non-Copy
data, so we should figure out how to handle this now.</p>
<p>The <em>right</em> answer is to pull the <em>whole</em> node out of the Box, so that we can
tear it apart in peace. We do that by explicitly dereferencing it:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match mem::replace(&amp;mut self.head, Link::Empty) {
        Link::Empty =&gt; None,
        Link::More(boxed_node) =&gt; {
            let node = *boxed_node;
            self.head = node.next;
            Some(node.elem)
        }
    }
}
#}</code></pre></pre>
<p>After that, Rust understands an on-the-stack value well enough to let you take
it apart piece-by-piece.</p>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
</code></pre>
<p>Nice.</p>
<p>Box is actually really special in Rust, because it's sufficiently built into the
language that the compiler lets you do some stuff that nothing else can do. We
actually have been doing one such thing this whole time: <code>DerefMove</code>. Whenever
you have a pointer type you can dereference it with <code>*</code> or <code>.</code> to get at its
contents. Usually you can get a <code>Deref</code> or maybe even a <code>DerefMut</code>,
corresponding to a shared or mutable reference respectively.</p>
<p>However because Box totally owns its contents, you can actually <em>move out of</em>
a dereference. This is total magic, because there's no way for any other type
to opt into this. There's tons of other cool tricks the compiler knows how to do
with Box because it <em>just is</em> Box, but they were all feature-gated at 1.0
pending further design. Ideally Box will be totally user definable in the
future.</p>
<a class="header" href="#testing" id="testing"><h1>Testing</h1></a>
<p>Alright, so we've got <code>push</code> and <code>pop</code> written, now we can actually test out
our stack! Rust and cargo support testing as a first-class feature, so this
will be super easy. All we have to do is write a function, and annotate it with
<code>#[test]</code>.</p>
<p>Generally, we try to keep our tests next to the code that its testing in the
Rust community. However we usually make a new namespace for the tests, to
avoid conflicting with the &quot;real&quot; code. Just as we used <code>mod</code> to specify that
<code>first.rs</code> should be included in <code>lib.rs</code>, we can use <code>mod</code> to basically
create a whole new file <em>inline</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// in first.rs

mod test {
    #[test]
    fn basics() {
        // TODO
    }
}
#}</code></pre></pre>
<p>And we invoke it with <code>cargo test</code>.</p>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 1 test
test first::test::basics ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Yay our do-nothing test passed! Let's make it not-do-nothing. We'll do that
with the <code>assert_eq!</code> macro. This isn't some special testing magic. All it
does is compare the two things you give it, and panic the program if they don't
match. Yep, you indicate failure to the test harness by freaking out!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod test {
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/first.rs:47:24: 47:33 error: failed to resolve. Use of undeclared type or module `List` [E0433]
src/first.rs:47         let mut list = List::new();
                                       ^~~~~~~~~
src/first.rs:47:24: 47:33 error: unresolved name `List::new` [E0425]
src/first.rs:47         let mut list = List::new();
                                       ^~~~~~~~~
error: aborting due to 2 previous errors
</code></pre>
<p>Oops! Because we made a new module, we need to pull in List explicitly to use
it.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod test {
    use super::List;
    // everything else the same
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/first.rs:45:9: 45:20 warning: unused import, #[warn(unused_imports)] on by default
src/first.rs:45     use super::List;
                        ^~~~~~~~~~~
     Running target/debug/lists-5c71138492ad4b4a

running 1 test
test first::test::basics ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Yay!</p>
<p>What's up with that warning though...? We clearly use List in our test!</p>
<p>...but only when testing! To appease the compiler (and to be friendly to our
consumers), we should indicate that the whole <code>test</code> module should only be
compiled if we're running tests.</p>
<pre><code>#[cfg(test)]
mod test {
    use super::List;
    // everything else the same
}
</code></pre>
<p>And that's everything for testing!</p>
<a class="header" href="#drop" id="drop"><h1>Drop</h1></a>
<p>We can make a stack, push on to, pop off it, and we've even tested that it all
works right!</p>
<p>Do we need to worry about cleaning up our list? Technically, no, not at all!
Like C++, Rust uses destructors to automatically clean up resources when they're
done with. A type has a destructor if it implements a <em>trait</em> called Drop.
Traits are Rust's fancy term for interfaces. The Drop trait has the following
interface:</p>
<pre><code>pub trait Drop {
    fn drop(&amp;mut self);
}
</code></pre>
<p>Basically, &quot;when you go out of scope, I'll give you a second to clean up your
affairs&quot;.</p>
<p>You don't actually need to implement Drop if you contain types that implement
Drop, and all you'd want to do is call <em>their</em> destructors. In the case of
List, all it would want to do is drop its head, which in turn would <em>maybe</em>
try to drop a <code>Box&lt;Node&gt;</code>. All that's handled for us automatically... with one
hitch.</p>
<p>The automatic handling is going to be bad.</p>
<p>Let's consider a simple list:</p>
<pre><code class="language-text">list -&gt; A -&gt; B -&gt; C
</code></pre>
<p>When <code>list</code> gets dropped, it will try to drop A, which will try to drop B,
which will try to drop C. Some of you might rightly be getting nervous. This is
recursive code, and recursive code can blow the stack!</p>
<p>Some of you might be thinking &quot;this is clearly tail recursive, and any decent
language would ensure that such code wouldn't blow the stack&quot;. This is, in fact,
incorrect! To see why, let's try to write what the compiler has to do, by
manually implementing Drop for our List as the compiler would:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Drop for List {
    fn drop(&amp;mut self) {
        // NOTE: you can't actually explicitly call `drop` in real Rust code;
        // we're pretending to be the compiler!
        self.head.drop(); // tail recursive - good!
    }
}

impl Drop for Link {
    fn drop(&amp;mut self) {
        match *self {
            Link::Empty =&gt; {} // Done!
            Link::More(ref mut boxed_node) =&gt; {
                boxed_node.drop(); // tail recursive - good!
            }
        }
    }
}

impl Drop for Box&lt;Node&gt; {
    fn drop(&amp;mut self) {
        self.ptr.drop(); // uh oh, not tail recursive!
        deallocate(self.ptr);
    }
}

impl Drop for Node {
    fn drop(&amp;mut self) {
        self.next.drop();
    }
}
#}</code></pre></pre>
<p>We <em>can't</em> drop the contents of the Box <em>after</em> deallocating, so there's no
way to drop in a tail-recursive manner! Instead we're going to have to manually
write an iterative drop for <code>List</code> that hoists nodes out of their boxes.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = mem::replace(&amp;mut self.head, Link::Empty);
        // `while let` == &quot;do this thing until this pattern doesn't match&quot;
        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&amp;mut boxed_node.next, Link::Empty);
            // boxed_node goes out of scope and gets dropped here;
            // but its Node's `next` field has been set to Link::Empty
            // so no unbounded recursion occurs.
        }
    }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 1 test
test first::test::basics ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Great!</p>
<a class="header" href="#the-final-code" id="the-final-code"><h1>The Final Code</h1></a>
<p>Alright, 6000 words later, here's all the code we managed to actually write:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::mem;

pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -&gt; Self {
        List { head: Link::Empty }
    }

    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match mem::replace(&amp;mut self.head, Link::Empty) {
            Link::Empty =&gt; None,
            Link::More(node) =&gt; {
                let node = *node;
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = mem::replace(&amp;mut self.head, Link::Empty);
        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&amp;mut boxed_node.next, Link::Empty);
        }
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}
#}</code></pre></pre>
<p>Geez. 80 lines, and half of it was tests! Well, I did say this first one was
going to take a while!</p>
<a class="header" href="#an-ok-singly-linked-stack" id="an-ok-singly-linked-stack"><h1>An Ok Singly-Linked Stack</h1></a>
<p>In the previous chapter we wrote up basically a minimum viable singly-linked
stack. However there's a few design decisions that make it kind of sucky.
Let's make it less sucky. In doing so, we will:</p>
<ul>
<li>Deinvent the wheel</li>
<li>Make our list able to handle any element type</li>
<li>Add peeking</li>
<li>Make our list iterable</li>
</ul>
<p>And in the process we'll learn about</p>
<ul>
<li>Advanced Option use</li>
<li>Generics</li>
<li>Lifetimes</li>
<li>Iterators</li>
</ul>
<p>Let's add a new file called <code>second.rs</code>:</p>
<pre><code>// in lib.rs

pub mod first;
pub mod second;
</code></pre>
<p>And copy everything from <code>first.rs</code> into it.</p>
<a class="header" href="#using-option" id="using-option"><h1>Using Option</h1></a>
<p>Particularly observant readers may have noticed that we actually reinvented
a really bad version of Option:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}
#}</code></pre></pre>
<p>Link is just <code>Option&lt;Box&lt;Node&gt;&gt;</code>. Now, it's nice not to have to write
<code>Option&lt;Box&lt;Node&gt;&gt;</code> everywhere, and unlike <code>pop</code>, we're not exposing this
to the outside world, so maybe it's fine. However Option has some <em>really
nice</em> methods that we've been manually implementing ourselves. Let's <em>not</em>
do that, and replace everything with Options. First, we'll do it naively
by just renaming everything to use Some and None:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::mem;

pub struct List {
    head: Link,
}

// yay type aliases!
type Link = Option&lt;Box&lt;Node&gt;&gt;;

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&amp;mut self.head, None),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match mem::replace(&amp;mut self.head, None) {
            None =&gt; None,
            Some(node) =&gt; {
                let node = *node;
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = mem::replace(&amp;mut self.head, None);
        while let Some(mut boxed_node) = cur_link {
            cur_link = mem::replace(&amp;mut boxed_node.next, None);
        }
    }
}
#}</code></pre></pre>
<p>This is marginally better, but the big wins will come from Option's methods.</p>
<p>First, <code>mem::replace(&amp;mut option, None)</code> is such an incredibly
common idiom that Option actually just went ahead and made it a method: <code>take</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct List {
    head: Link,
}

type Link = Option&lt;Box&lt;Node&gt;&gt;;

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match self.head.take() {
            None =&gt; None,
            Some(node) =&gt; {
                let node = *node;
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
#}</code></pre></pre>
<p>Second, <code>match option { None =&gt; None, Some(x) =&gt; Some(y) }</code> is such an
incredibly common idiom that it was called <code>map</code>. <code>map</code> takes a function to
execute on <code>x</code> in the <code>Some(x)</code> to produce the <code>y</code> in <code>Some(y)</code>. We could
write a proper <code>fn</code> and pass it to <code>map</code>, but we'd much rather write what to
do <em>inline</em>.</p>
<p>The way to do this is with a <em>closure</em>. Closures are anonymous functions with
an extra super-power: they can refer to local variables <em>outside</em> the closure!
This makes them super useful for doing all sorts of conditional logic. The
only place we do a <code>match</code> is in <code>pop</code>, so let's just rewrite that:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    self.head.take().map(|node| {
        let node = *node;
        self.head = node.next;
        node.elem
    })
}
#}</code></pre></pre>
<p>Ah, much better. Let's make sure we didn't break anything:</p>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Great! Let's move on to actually improving the code's <em>behaviour</em>.</p>
<a class="header" href="#making-it-all-generic" id="making-it-all-generic"><h1>Making it all Generic</h1></a>
<p>We've already touched a bit on generics with Option and Box. However so
far we've managed to avoid declaring any new type that is actually generic
over arbitrary elements.</p>
<p>It turns out that's actually really easy. Let's make all of our types generic
right now:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
#}</code></pre></pre>
<p>You just make everything a little more pointy, and suddenly your code is
generic. Of course, we can't <em>just</em> do this, or else the compiler's going
to be Super Mad.</p>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/second.rs:12:6: 12:10 error: wrong number of type arguments: expected 1, found 0 [E0243]
src/second.rs:12 impl List {
                      ^~~~
src/second.rs:12:6: 12:10 help: run `rustc --explain E0243` to see a detailed explanation
src/second.rs:35:15: 35:19 error: wrong number of type arguments: expected 1, found 0 [E0243]
src/second.rs:35 impl Drop for List {
                               ^~~~
src/second.rs:35:15: 35:19 help: run `rustc --explain E0243` to see a detailed explanation
error: aborting due to 2 previous errors
</code></pre>
<p>The compiler is even telling us about some fancy error code, but honestly the
problem is pretty clear, we're talking about this <code>List</code> thing but that's not
real anymore. Like Option and Box, we now always have to talk about
<code>List&lt;Something&gt;</code>.</p>
<p>But what's the Something we use in all these impls? Just like List, we want our
implementations to work with <em>all</em> the T's. So, just like List, let's make our
<code>impl</code>s pointy:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            let node = *node;
            self.head = node.next;
            node.elem
        })
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
#}</code></pre></pre>
<p>...and that's it!</p>
<pre><code>&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>All of our code is now completely generic over arbitrary values of T. Dang,
Rust is <em>easy</em>. I'd like to make a particular shout-out to <code>new</code> which didn't
even change:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn new() -&gt; Self {
    List { head: None }
}
#}</code></pre></pre>
<p>Bask in the Glory that is Self, guardian of refactoring and copy-pasta coding.
Also of interest, we don't write <code>List&lt;T&gt;</code> when we construct an instance of
list. That part's inferred for us based on the fact that we're returning it
from a function that expects a <code>List&lt;T&gt;</code>.</p>
<p>Alright, let's move on to totally new <em>behaviour</em>!</p>
<a class="header" href="#peek" id="peek"><h1>Peek</h1></a>
<p>One thing we didn't even bother to implement last time was peeking. Let's go
ahead and do that. All we need to do is return a reference to the element in
the head of the list, if it exists. Sounds easy, let's try:</p>
<pre><code>pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.map(|node| {
        &amp;node.elem
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/second.rs:45:9: 45:18 error: cannot move out of type `second::List&lt;T&gt;`, which defines the `Drop` trait
src/second.rs:45         self.head.map(|node| {
                         ^~~~~~~~~
src/second.rs:46:14: 46:23 error: `node.elem` does not live long enough
src/second.rs:46             &amp;node.elem
                              ^~~~~~~~~
note: in expansion of closure expansion
src/second.rs:45:23: 47:10 note: expansion site
src/second.rs:44:38: 48:6 note: reference must be valid for the anonymous lifetime #1 defined on the block at 44:37...
src/second.rs:44     pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
src/second.rs:45         self.head.map(|node| {
src/second.rs:46             &amp;node.elem
src/second.rs:47         })
src/second.rs:48     }
src/second.rs:45:30: 47:10 note: ...but borrowed value is only valid for the scope of parameters for function at 45:29
src/second.rs:45         self.head.map(|node| {
src/second.rs:46             &amp;node.elem
src/second.rs:47         })
error: aborting due to 2 previous errors
</code></pre>
<p><em>Sigh</em>. What now, Rust?</p>
<p>Map takes <code>self</code> by value, which would move the Option out of the thing it's in.
Previously this was fine because we had just <code>take</code>n it out, but now we actually
want to leave it where it was. The <em>correct</em> way to handle this is with the
<code>as_ref</code> method on Option, which has the following definition:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; Option&lt;T&gt; {
    pub fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;;
}
#}</code></pre></pre>
<p>It demotes the Option<T> to an Option to a reference to its internals. We could
do this ourselves with an explicit match but <em>ugh no</em>. It does mean that we
need to do an extra dereference to cut through the extra indirection, but
thankfully the <code>.</code> operator handles that for us.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| {
        &amp;node.elem
    })
}
#}</code></pre></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
</code></pre>
<p>Nailed it.</p>
<p>We can also make a <em>mutable</em> version of this method using <code>as_mut</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    self.head.as_mut().map(|node| {
        &amp;mut node.elem
    })
}
#}</code></pre></pre>
<pre><code class="language-text">lists::cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
</code></pre>
<p>EZ</p>
<p>Don't forget to test it:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn peek() {
    let mut list = List::new();
    assert_eq!(list.peek(), None);
    assert_eq!(list.peek_mut(), None);
    list.push(1); list.push(2); list.push(3);

    assert_eq!(list.peek(), Some(&amp;3));
    assert_eq!(list.peek_mut(), Some(&amp;mut 3));
}
#}</code></pre></pre>
<pre><code>cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 3 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::peek ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>That's nice, but we didn't really test to see if we could mutate that <code>peek_mut</code> return value, did we?  If a reference is mutable but nobody mutates it, have we really tested the mutability?  Let's try using <code>map</code> on this <code>Option&lt;&amp;mut T&gt;</code> to put a profound value in:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn peek() {
    let mut list = List::new();
    assert_eq!(list.peek(), None);
    assert_eq!(list.peek_mut(), None);
    list.push(1); list.push(2); list.push(3);

    assert_eq!(list.peek(), Some(&amp;3));
    assert_eq!(list.peek_mut(), Some(&amp;mut 3));
    list.peek_mut().map(|&amp;mut value| {
        value = 42 });

    assert_eq!(list.peek(), Some(&amp;42));
    assert_eq!(list.pop(), Some(42));
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/second.rs:158:13: 158:23 error: re-assignment of immutable variable `value` [E0384]
src/second.rs:158             value = 42 });
                              ^~~~~~~~~~
src/second.rs:158:13: 158:23 help: run `rustc --explain E0384` to see a detailed explanation
src/second.rs:157:35: 157:40 note: prior assignment occurs here
src/second.rs:157         list.peek_mut().map(|&amp;mut value| {
                                                    ^~~~~
error: aborting due to previous error
</code></pre>
<p>The compiler is complaining that <code>value</code> is immutable, but we pretty clearly wrote <code>&amp;mut value</code>; what gives?  It turns out that writing the argument of the closure that way doesn't specify that <code>value</code> is a mutable reference but instead creates a pattern that will be matched against the argument to the closure; <code>|&amp;mut value|</code> means &quot;the argument is a mutable reference, but just stick the immutable value into <code>value</code>, please.&quot;  If we just use <code>|value|</code>, the type of <code>value</code> will be <code>&amp;mut i32</code> and we can actually mutate the head:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    #[test]
    fn peek() {
        let mut list = List::new();
        assert_eq!(list.peek(), None);
        assert_eq!(list.peek_mut(), None);
        list.push(1); list.push(2); list.push(3);

        assert_eq!(list.peek(), Some(&amp;3));
        assert_eq!(list.peek_mut(), Some(&amp;mut 3));

        list.peek_mut().map(|value| {
            *value = 42 });

        assert_eq!(list.peek(), Some(&amp;42));
        assert_eq!(list.pop(), Some(42));
    }
#}</code></pre></pre>
<pre><code class="language-text">cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 3 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::peek ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Much better!</p>
<a class="header" href="#intoiter" id="intoiter"><h1>IntoIter</h1></a>
<p>Collections are iterated in Rust using the <em>Iterator</em> trait. It's a bit more
complicated than <code>Drop</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
#}</code></pre></pre>
<p>The new kid on the block here is <code>type Item</code>. This is declaring that every
implementation of Iterator has an <em>associated type</em> called Item. In this case,
this is the type of this that it can spit out when you call <code>next</code>.</p>
<p>The reason Iterator yields <code>Option&lt;Self::Item&gt;</code> is because the interface
coalesces the <code>has_next</code> and <code>get_next</code> concepts. When you have the next value,
you yield
<code>Some(value)</code>, and when you don't you yield <code>None</code>. This makes the
API generally more ergonomic and safe to use and implement, while avoiding
redundant checks and logic between <code>has_next</code> and <code>get_next</code>. Nice!</p>
<p>Sadly, Rust has nothing like a <code>yield</code> statement, so we're going to have to
implement the logic ourselves. Also, there's actually 3 different kinds of
iterator each collection should endeavour to implement:</p>
<ul>
<li>IntoIter - <code>T</code></li>
<li>IterMut - <code>&amp;mut T</code></li>
<li>Iter - <code>&amp;T</code></li>
</ul>
<p>We actually already have all the tools to implement
IntoIter using List's interface: just call <code>pop</code> over and over. As such, we'll
just implement IntoIter as a newtype wrapper around List:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Tuple structs are an alternative form of struct,
// useful for trivial wrappers around other types.
pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // access fields of a tuple struct numerically
        self.0.pop()
    }
}
#}</code></pre></pre>
<p>And let's write a test:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn into_iter() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), None);
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 4 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Nice!</p>
<a class="header" href="#iter" id="iter"><h1>Iter</h1></a>
<p>Alright, let's try to implement Iter. This time we won't be able to rely on
List giving us all the features we want. We'll need to roll our own. The
basic logic we want is to hold a pointer to the current node we want to yield
next. Because that node may not exist (the list is empty or we're otherwise
done iterating), we want that reference to be an Option. When we yield an
element, we want to proceed to the current node's <code>next</code> node.</p>
<p>Alright, let's try that:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Iter&lt;T&gt; {
    next: Option&lt;&amp;Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.map(|node| &amp;*node) }
    }
}

impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
    type Item = &amp;T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;*node);
            &amp;node.elem
        })
    }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/second.rs:62:18: 62:26 error: missing lifetime specifier [E0106]
src/second.rs:62     next: Option&lt;&amp;Node&lt;T&gt;&gt;,
                                  ^~~~~~~~
src/second.rs:62:18: 62:26 help: run `rustc --explain E0106` to see a detailed explanation
src/second.rs:72:17: 72:19 error: missing lifetime specifier [E0106]
src/second.rs:72     type Item = &amp;T;
                                 ^~
src/second.rs:72:17: 72:19 help: run `rustc --explain E0106` to see a detailed explanation
error: aborting due to 2 previous errors
</code></pre>
<p>Oh god. Lifetimes. I've heard of these things. I hear they're a nightmare. Let's
try that <code>--explain</code>:</p>
<pre><code>&gt; rustc --explain E0106
This error indicates that a lifetime is missing from a type. If it is an error
inside a function signature, the problem may be with failing to adhere to the
lifetime elision rules (see below).

Here are some simple examples of where you'll run into this error:

struct Foo { x: &amp;bool }        // error
struct Foo&lt;'a&gt; { x: &amp;'a bool } // correct

enum Bar { A(u8), B(&amp;bool), }        // error
enum Bar&lt;'a&gt; { A(u8), B(&amp;'a bool), } // correct

type MyStr = &amp;str;        // error
type MyStr&lt;'a&gt; = &amp;'a str; //correct
...

</code></pre>
<p>That uh... that didn't really clarify much. But it looks like we should add
those <code>'a</code> things to our struct? Let's try that.</p>
<pre><code>pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/second.rs:71:22: 71:29 error: wrong number of lifetime parameters: expected 1, found 0 [E0107]
src/second.rs:71 impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
                                      ^~~~~~~
src/second.rs:71:22: 71:29 help: run `rustc --explain E0107` to see a detailed explanation
src/second.rs:72:17: 72:19 error: missing lifetime specifier [E0106]
src/second.rs:72     type Item = &amp;T;
                                 ^~
src/second.rs:72:17: 72:19 help: run `rustc --explain E0106` to see a detailed explanation
error: aborting due to 2 previous errors

</code></pre>
<p>Alright I'm starting to see a pattern here... let's just go whole-hog here:</p>
<pre><code>pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; List&lt;T&gt; {
    pub fn iter(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.map(|node| &amp;'a *node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;'a mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;'a *node);
            &amp;'a node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/second.rs:67:34: 67:35 error: expected `:`, found `*`
src/second.rs:67         self.head.map(|node| &amp;'a **node)
                                                  ^
Could not compile `lists`.
</code></pre>
<p>Oh god. We broke Rust.</p>
<p>Maybe we should actually figure out what the heck this <code>'a</code> lifetime stuff
even means.</p>
<p>Lifetimes can scare off a lot of people because
they're a change to something we've known and loved since the dawn of
programming. We've actually managed to dodge lifetimes so far, even though
they've been tangled throughout our programs this whole time.</p>
<p>Lifetimes are unnecessary in garbage collected languages because the garbage
collector ensures that everything magically lives as long as it needs to. Most
data in Rust is <em>manually</em> managed, so that data needs another solution. C and
C++ give us a clear example what happens if you just let people take pointers
to random data on the stack: pervasive unmanageable unsafety. This can be
roughly seperated into two classes of error:</p>
<ul>
<li>Holding a pointer to something that went out of scope</li>
<li>Holding a pointer to something that got mutated away</li>
</ul>
<p>Lifetimes solve both of these problems, and 99% of the time, they do this in
a totally transparent way.</p>
<p>So what's a lifetime?</p>
<p>Quite simply, a lifetime is the name of a scope somewhere in a program.
That's it. When a reference is tagged with a lifetime, we're saying that it
has to be valid for that <em>entire</em> scope. Different things place requirements on
how long a reference must and can be valid for. The entire lifetime system is in
turn just a constraint-solving system that tries to minimize the scope of every
reference. If it sucessfully finds a set of lifetimes that satisfies all the
constraints, your program compiles! Otherwise you get an error back saying that
something didn't live long enough.</p>
<p>Within a function body you generally can't talk about lifetimes, and wouldn't
want to <em>anyway</em>. The compiler has full information and can infer all the
contraints and find the minimum lifetimes. However at the type and API-level,
the compiler <em>doesn't</em> have all the information. It requires you to tell it
about the relationship between different lifetimes so it can figure out what
you're doing.</p>
<p>In principle, those lifetimes <em>could</em> also be left out, but
then checking all the borrows would be a huge whole-program analysis that would
produce mind-bogglingly non-local errors. Rust's system means all borrow
checking can be done in each function body independently, and all your errors
should be fairly local (or your types have incorrect signatures).</p>
<p>But we've written references in function signatures before, and it was fine!
That's because there are certain cases that are so common that Rust will
automatically pick the lifetimes for you. This is <em>lifetime elision</em>.</p>
<p>In particular:</p>
<pre><code class="language-rust ignore">// Only one reference in input, so the output must be derived from that input
fn foo(&amp;A) -&gt; &amp;B; // sugar for:
fn foo&lt;'a&gt;(&amp;'a A) -&gt; &amp;'a B;

// Many inputs, assume they're all independent
fn foo(&amp;A, &amp;B, &amp;C); // sugar for:
fn foo&lt;'a, 'b, 'c&gt;(&amp;'a, &amp;'b, &amp;'c);

// Methods, assume all output lifetimes are derived from `self`
fn foo(&amp;self, &amp;B, &amp;C) -&gt; &amp;D; // sugar for:
fn foo&lt;'a, 'b, 'c&gt;(&amp;'a self, &amp;'b B, &amp;'c C) -&gt; &amp;'a D;
</code></pre>
<p>So what does <code>fn foo&lt;'a&gt;(&amp;'a A) -&gt; &amp;'a B</code> <em>mean</em>? In practical terms, all it
means is that the input must live at least as long as the output. So if you keep
the output around for a long time, this will <em>drag</em> the scope that the <code>&amp;A</code> must
be valid for to be larger and larger.</p>
<p>With this system set up, Rust can ensure nothing is used after free, and nothing
is mutated while outstanding references exist. It just makes sure the
constraints all work out!</p>
<p>Alright. So. Iter.</p>
<p>Let's roll back to the no lifetimes state:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Iter&lt;T&gt; {
    next: Option&lt;&amp;Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.map(|node| &amp;*node) }
    }
}

impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
    type Item = &amp;T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;*node);
            &amp;node.elem
        })
    }
}
#}</code></pre></pre>
<p>We need to add lifetimes only in function and type signatures:</p>
<pre><code>// Iter is generic over *some* lifetime, it doesn't care
pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

// No lifetime here, List doesn't have any associated lifetimes
impl&lt;T&gt; List&lt;T&gt; {
    // We declare a fresh lifetime here for the *exact* borrow that
    // creates the iter. Now &amp;self needs to be valid as long as the
    // Iter is around.
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.map(|node| &amp;*node) }
    }
}

// *Do* have a lifetime here, because Iter does have an associated lifetime
impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    // Need it here too, this is a type declaration
    type Item = &amp;'a T;

    // None of this needs to change, handled by the above.
    // Self continues to be incredibly hype and amazing
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}
</code></pre>
<p>Alright, I think we got it this time y'all.</p>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/second.rs:62:1: 64:2 error: the parameter type `T` may not live long enough [E0309]
src/second.rs:62 pub struct Iter&lt;'a, T&gt; {
src/second.rs:63     next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
src/second.rs:64 }
src/second.rs:62:1: 64:2 help: run `rustc --explain E0309` to see a detailed explanation
src/second.rs:62:1: 64:2 help: consider adding an explicit lifetime bound `T: 'a`...
src/second.rs:62:1: 64:2 note: ...so that the reference type `&amp;'a second::Node&lt;T&gt;` does not outlive the data it points at
src/second.rs:62 pub struct Iter&lt;'a, T&gt; {
src/second.rs:63     next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
src/second.rs:64 }
error: aborting due to previous error
</code></pre>
<p>(╯°□°)╯︵ ┻━┻</p>
<pre><code class="language-text">rustc --explain E0309
Types in type definitions have lifetimes associated with them that represent
how long the data stored within them is guaranteed to be live. This lifetime
must be as long as the data needs to be alive, and missing the constraint that
denotes this will cause this error.

// This won't compile because T is not constrained, meaning the data
// stored in it is not guaranteed to last as long as the reference
struct Foo&lt;'a, T&gt; {
    foo: &amp;'a T
}

// This will compile, because it has the constraint on the type parameter
struct Foo&lt;'a, T: 'a&gt; {
    foo: &amp;'a T
}
</code></pre>
<p>This is dumb. I think it's dumb. You have to do it.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Iter&lt;'a, T: 'a&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}
#}</code></pre></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/second.rs:67:22: 67:31 error: cannot move out of type `second::List&lt;T&gt;`, which defines the `Drop` trait
src/second.rs:67         Iter { next: self.head.map(|node| &amp;*node) }
                                      ^~~~~~~~~
src/second.rs:67:44: 67:49 error: `*node` does not live long enough
src/second.rs:67         Iter { next: self.head.map(|node| &amp;*node) }
                                                            ^~~~~
note: in expansion of closure expansion
src/second.rs:67:36: 67:49 note: expansion site
src/second.rs:66:42: 68:6 note: reference must be valid for the lifetime 'a as defined on the block at 66:41...
src/second.rs:66     pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
src/second.rs:67         Iter { next: self.head.map(|node| &amp;*node) }
src/second.rs:68     }
src/second.rs:67:43: 67:49 note: ...but borrowed value is only valid for the scope of parameters for function at 67:42
src/second.rs:67         Iter { next: self.head.map(|node| &amp;*node) }
                                                           ^~~~~~
src/second.rs:76:25: 76:29 error: cannot move out of borrowed content
src/second.rs:76             self.next = node.next.map(|node| &amp;*node);
                                         ^~~~
note: in expansion of closure expansion
src/second.rs:75:23: 78:10 note: expansion site
src/second.rs:76:47: 76:52 error: `*node` does not live long enough
src/second.rs:76             self.next = node.next.map(|node| &amp;*node);
                                                               ^~~~~
note: in expansion of closure expansion
src/second.rs:76:39: 76:52 note: expansion site
note: in expansion of closure expansion
src/second.rs:75:23: 78:10 note: expansion site
src/second.rs:74:46: 79:6 note: reference must be valid for the lifetime 'a as defined on the block at 74:45...
src/second.rs:74     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
src/second.rs:75         self.next.map(|node| {
src/second.rs:76             self.next = node.next.map(|node| &amp;*node);
src/second.rs:77             &amp;node.elem
src/second.rs:78         })
src/second.rs:79     }
src/second.rs:76:46: 76:52 note: ...but borrowed value is only valid for the scope of parameters for function at 76:45
src/second.rs:76             self.next = node.next.map(|node| &amp;*node);
                                                              ^~~~~~
error: aborting due to 4 previous errors
</code></pre>
<p>(ﾉಥ益ಥ）ﾉ﻿ ┻━┻</p>
<p>We forgot <code>as_ref</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Iter&lt;'a, T:'a&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}
#}</code></pre></pre>
<pre><code class="language-text">lists::cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
</code></pre>
<p>┬─┬﻿ ノ( ゜-゜ノ)</p>
<p>Let's write a test to be sure we didn't no-op it or anything:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iter() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&amp;3));
    assert_eq!(iter.next(), Some(&amp;2));
    assert_eq!(iter.next(), Some(&amp;1));
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 5 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::peek ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Heck yeah.</p>
<p>Finally, it should be noted that we actually apply lifetime elision here:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }
}
#}</code></pre></pre>
<p>is equivalent to:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }
}
#}</code></pre></pre>
<p>Yay less lifetimes!</p>
<a class="header" href="#itermut" id="itermut"><h1>IterMut</h1></a>
<p>I'm gonna be honest, IterMut is crazy. Which in itself seems like a crazy
thing to say; surely it's identical to Iter!</p>
<p>Semantically, yes. However the nature of shared and mutable references means
that Iter is &quot;trivial&quot; while IterMut is Legit Wizard Magic.</p>
<p>The key insight comes from our implementation of Iterator for Iter:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { /* stuff */ }
}
#}</code></pre></pre>
<p>Which can be desugarred to:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next&lt;'b&gt;(&amp;'b mut self) -&gt; Option&lt;&amp;'a T&gt; { /* stuff */ }
}
#}</code></pre></pre>
<p>The signature of <code>next</code> establishes <em>no</em> constraint between the lifetime
of the input and the output! Why do we care? It means we can call <code>next</code>
over and over unconditionally!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut list = List::new();
list.push(1); list.push(2); list.push(3);

let mut iter = list.iter();
let x = iter.next().unwrap();
let y = iter.next().unwrap();
let z = iter.next().unwrap();
#}</code></pre></pre>
<p>Cool!</p>
<p>This is <em>definitely fine</em> for shared references because the whole point is that
you can have tons of them at once. However mutable references <em>can't</em> coexist.
The whole point is that they're exclusive.</p>
<p>The end result is that it's notably harder to write an IterMut using safe
code (and we haven't gotten into what that even means yet...). Surprisingly,
IterMut can actually be implemented for many structures completely safely!
Borrow checking magic!</p>
<p>We'll start by just taking the Iter code and changing everything to be mutable:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct IterMut&lt;'a, T: 'a&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_mut().map(|node| &amp;mut **node);
            &amp;mut node.elem
        })
    }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/second.rs:96:25: 96:34 error: cannot borrow immutable field `self.head` as mutable
src/second.rs:96         IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
                                         ^~~~~~~~~
src/second.rs:104:9: 104:13 error: cannot move out of borrowed content
src/second.rs:104         self.next.map(|node| {
                          ^~~~
error: aborting due to previous error
</code></pre>
<p>Oops! I actually accidentally made an error when writing the
<code>iter</code> impl, but Copy saved the day. <code>&amp;</code> is Copy, as we saw before. But
that also means <code>Option&lt;&amp;&gt;</code> is <em>also</em> Copy. So when we did <code>self.next.map</code> it
was fine because the Option was just copied. Now we can't do that, because
<code>&amp;mut</code> isn't Copy (if you copied an &amp;mut, you'd have two &amp;mut's to the same
location in memory, which is verboten). Instead, we should properly <code>take</code>
the Option to get it.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    self.next.take().map(|node| {
        self.next = node.next.as_mut().map(|node| &amp;mut **node);
        &amp;mut node.elem
    })
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
src/second.rs:65:25: 65:34 error: cannot borrow immutable field `self.head` as mutable
src/second.rs:65         IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
                                         ^~~~~~~~~
error: aborting due to previous error
</code></pre>
<p>Uh... what? Looks we messed up mutability somewhere in <code>iter_mut</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn iter_mut(&amp;self) -&gt; IterMut&lt;T&gt; {
    IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
}
#}</code></pre></pre>
<p>Classic copy-paste error. <code>self</code> is a shared reference! We can't
get mutable references out of that!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
    IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
</code></pre>
<p>Uh... wow. Holy shit! IterMut Just Works!</p>
<p>Let's test this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iter_mut() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.iter_mut();
    assert_eq!(iter.next(), Some(&amp;mut 3));
    assert_eq!(iter.next(), Some(&amp;mut 2));
    assert_eq!(iter.next(), Some(&amp;mut 1));
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 6 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::peek ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Yep. It works.</p>
<p>Holy shit.</p>
<p>What.</p>
<p>Ok I mean it actually <em>is</em> supposed to work, but there's usually something
stupid that gets in the way! Let's be clear here:</p>
<p>We have just implemented a piece of code that takes a singly-linked list, and
returns a mutable reference to every single element in the list at most once.
And it's statically verified to do that. And it's totally safe. And we didn't
have to do anything crazy.</p>
<p>That's kind of a big deal, if you ask me. There are a couple reasons why
this works:</p>
<ul>
<li>We <code>take</code> the <code>Option&lt;&amp;mut&gt;</code> so we have exclusive access to the mutable
reference. No need to worry about someone looking at it again.</li>
<li>Rust understands that it's ok to shard a mutable reference into the subfields
of the pointed-to struct, because there's no way to &quot;go back up&quot;, and they're
definitely disjoint.</li>
</ul>
<p>It turns out that you can apply this basic logic to get a safe IterMut for an
array or a tree as well! You can even make the iterator DoubleEnded, so that
you can consume the iterator from the front <em>and</em> the back at once! Wild!</p>
<a class="header" href="#final-code" id="final-code"><h1>Final Code</h1></a>
<p>Alright, that's it for the second list; here's the final code!</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

pub struct Iter&lt;'a, T:'a&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

pub struct IterMut&lt;'a, T: 'a&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}



impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            let node = *node;
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.take().map(|node| {
            self.next = node.next.as_mut().map(|node| &amp;mut **node);
            &amp;mut node.elem
        })
    }
}


#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert_eq!(list.peek(), None);
        assert_eq!(list.peek_mut(), None);
        list.push(1); list.push(2); list.push(3);

        assert_eq!(list.peek(), Some(&amp;3));
        assert_eq!(list.peek_mut(), Some(&amp;mut 3));
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(1));
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;1));
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&amp;mut 3));
        assert_eq!(iter.next(), Some(&amp;mut 2));
        assert_eq!(iter.next(), Some(&amp;mut 1));
    }
}

</code></pre></pre>
<p>Getting beefier!</p>
<a class="header" href="#a-persistent-singly-linked-stack" id="a-persistent-singly-linked-stack"><h1>A Persistent Singly-Linked Stack</h1></a>
<p>Alright, we've mastered the art of mutable singly-linked stacks.</p>
<p>Let's move from <em>single</em> ownership to <em>shared</em> ownership by writing a
<em>persistent</em> immutable singly linked list. This will be exactly the list
that functional programmers have come to know and love. You can get the
head <em>or</em> the tail and put someone's head on someone else's tail...
and... that's basically it. Immutability is a hell of a drug.</p>
<p>In the process we'll largely just become familiar with Rc and Arc, but this
will set us up for the next list which will <em>change the game</em>.</p>
<p>Let's add a new file called <code>third.rs</code>:</p>
<pre><code>// in lib.rs

pub mod first;
pub mod second;
pub mod third;
</code></pre>
<p>No copy-pasta this time. This is a clean room operation.</p>
<a class="header" href="#layout" id="layout"><h1>Layout</h1></a>
<p>Alright, back to the drawing board on layout.</p>
<p>The most important thing about
a persistent list is that you can manipulate the tails of lists basically
for free:</p>
<p>For instance, this isn't an uncommon workload to see with a persistent list:</p>
<pre><code class="language-text">list1 = A -&gt; B -&gt; C -&gt; D
list2 = tail(list1) = B -&gt; C -&gt; D
list3 = push(list2, X) = X -&gt; B -&gt; C -&gt; D
</code></pre>
<p>But at the end we want the memory to look like this:</p>
<pre><code class="language-text">list1 -&gt; A ---v
list2 ------&gt; B -&gt; C -&gt; D
list3 -&gt; X ---^
</code></pre>
<p>This just can't work with Boxes, because ownership of <code>B</code> is <em>shared</em>. Who
should free it? If I drop list2, does it free B? With boxes we certainly would
expect so!</p>
<p>Functional languages -- and indeed almost every other language -- get away with
this by using <em>garbage collection</em>. With the magic of garbage collection, B will
be freed only after everyone stops looking at it. Hooray!</p>
<p>Rust doesn't have anything like the garbage collectors these languages have.
They have <em>tracing</em> GC, which will dig through all the memory that's sitting
around at runtime and figure out what's garbage automatically. Instead, all
Rust has today is <em>reference counting</em>. Reference counting is basically a
poor-man's GC. For many workloads, it has significantly less throughput
than a tracing collector, and it completely falls over if you manage to
build cycles. Thankfully, for our usecase we'll never run into cycles
(feel free to try to prove this to yourself -- I sure won't).</p>
<p>So how do we do reference counted garbage collection? <code>Rc</code>! Rc is just like
Box, but we can duplicate it, and its memory will <em>only</em> be freed when <em>all</em>
the Rc's derived from it are dropped. Unforuntately, this flexibility comes at
a serious cost: we can only Deref an Rc. No DerefMut or DerefMove. This means
we can't ever really get data out of one of our lists, nor can we mutate them.</p>
<p>So what's our layout gonna look like? Well, previously we had:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
#}</code></pre></pre>
<p>Can we just change Box to Rc?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// in third.rs

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
#}</code></pre></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/third.rs:5:23: 5:34 error: use of undeclared type name `Rc` [E0412]
src/third.rs:5 type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;
                                     ^~~~~~~~~~~
error: aborting due to previous error
</code></pre>
<p>Oh dang, sick burn. Unlike everything we used for our mutable lists, Rc is so
lame that it's not even implicitly imported into every single Rust program.
<em>What a loser</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;
#}</code></pre></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/third.rs:4:5: 4:18 warning: struct field is never used: `head`, #[warn(dead_code)] on by default
src/third.rs:4     head: Link&lt;T&gt;,
                   ^~~~~~~~~~~~~
src/third.rs:10:5: 10:12 warning: struct field is never used: `elem`, #[warn(dead_code)] on by default
src/third.rs:10     elem: T,
                    ^~~~~~~
src/third.rs:11:5: 11:18 warning: struct field is never used: `next`, #[warn(dead_code)] on by default
src/third.rs:11     next: Link&lt;T&gt;,
                    ^~~~~~~~~~~~~
</code></pre>
<p>Seems legit. Rust continues to be a complete joke to write. I bet we can just
find-and-replace Box with Rc and call it a day.</p>
<p>...</p>
<p>No. No we can't.</p>
<a class="header" href="#basics" id="basics"><h1>Basics</h1></a>
<p>We already know a lot of the basics of Rust now, so we can do a lot of the
simple stuff again.</p>
<p>For the constructor, we can again just copy-paste:</p>
<pre><code>impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }
}
</code></pre>
<p><code>push</code> and <code>pop</code> don't really make sense anymore. Instead we can provide
<code>append</code> and <code>tail</code>, which provide approximately the same thing.</p>
<p>Let's start with appending. It takes a list and an element, and returns a
List. Like the mutable list case, we want to make a new node, that has the old
list as its <code>next</code> value. The only novel thing is how to <em>get</em> that next value,
because we're not allowed to mutate anything.</p>
<p>The answer to our prayers is the Clone trait. Clone is implemented by almost
every type, and provides a generic way to get &quot;another one like this one&quot; that
is logically disjoint given only a shared reference. It's like a copy
constructor in C++, but it's never implicitly invoked.</p>
<p>Rc in particular uses Clone as the way to increment the reference count. So
rather than moving a Box to be in the sublist, we just clone the head of the
old list. We don't even need to match on the head, because Option exposes a
Clone implementation that does exactly the thing we want.</p>
<p>Alright, let's give it a shot:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn append(&amp;self, elem: T) -&gt; List&lt;T&gt; {
    List { head: Some(Rc::new(Node {
        elem: elem,
        next: self.head.clone(),
    }))}
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/third.rs:10:5: 10:12 warning: struct field is never used: `elem`, #[warn(dead_code)] on by default
src/third.rs:10     elem: T,
                    ^~~~~~~
src/third.rs:11:5: 11:18 warning: struct field is never used: `next`, #[warn(dead_code)] on by default
src/third.rs:11     next: Link&lt;T&gt;,
                    ^~~~~~~~~~~~~
</code></pre>
<p>Wow, Rust is really hard-nosed about actually using fields. It can tell no
consumer can ever actually observe the use of these fields! Still, we seem good
so far.</p>
<p><code>tail</code> is the logical inverse of this operation. It takes a list and returns the
whole list with the first element removed. All that is is cloning the <em>second</em>
element in the list (if it exists). Let's try this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
    List { head: self.head.as_ref().map(|node| node.next.clone()) }
}
#}</code></pre></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/third.rs:28:22: 28:61 error: mismatched types:
 expected `core::option::Option&lt;alloc::rc::Rc&lt;third::Node&lt;_&gt;&gt;&gt;`,
    found `core::option::Option&lt;core::option::Option&lt;alloc::rc::Rc&lt;third::Node&lt;T&gt;&gt;&gt;&gt;`
(expected struct `alloc::rc::Rc`,
    found enum `core::option::Option`) [E0308]
src/third.rs:28         List { head: self.head.as_ref().map(|node| node.next.clone()) }
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/third.rs:28:22: 28:61 help: run `rustc --explain E0308` to see a detailed explanation
error: aborting due to previous error
</code></pre>
<p>Hrm, we messed up. <code>map</code> expects us to return a Y, but here we're returning an
<code>Option&lt;Y&gt;</code>. Thankfully, this is another common Option pattern, and we can just
use <code>and_then</code> to let us return an Option.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
    List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
</code></pre>
<p>Great.</p>
<p>Now that we have <code>tail</code>, we should probably provide <code>head</code>, which returns a
reference to the first element. That's just <code>peek</code> from the mutable list:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn head(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| &amp;node.elem )
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
</code></pre>
<p>Nice.</p>
<p>That's enough functionality that we can test it:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let list = List::new();
        assert_eq!(list.head(), None);

        let list = list.append(1).append(2).append(3);
        assert_eq!(list.head(), Some(&amp;3));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;2));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;1));

        let list = list.tail();
        assert_eq!(list.head(), None);

        // Make sure empty tail works
        let list = list.tail();
        assert_eq!(list.head(), None);

    }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 5 tests
test first::test::basics ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test third::test::basics ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Perfect!</p>
<p>Iter is identical to the mutable list case:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Iter&lt;'a, T:'a&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iter() {
    let list = List::new().append(1).append(2).append(3);

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&amp;3));
    assert_eq!(iter.next(), Some(&amp;2));
    assert_eq!(iter.next(), Some(&amp;1));
}
#}</code></pre></pre>
<pre><code class="language-text">cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 7 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Who ever said dynamic typing was easier?</p>
<p>(chumps did)</p>
<p>Note that we can't implement IntoIter or IterMut for this type. We only have
shared access to elements.</p>
<a class="header" href="#drop-1" id="drop-1"><h1>Drop</h1></a>
<p>Like the mutable lists, we have a recursive destructor problem.
Admittedly, this isn't as bad of a problem for the immutable list: if we ever
hit another node that's the head of another list <em>somewhere</em>, we won't
recursively drop it. However it's still a thing we should care about, and
how to deal with isn't as clear. Here's how we solved it before:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
#}</code></pre></pre>
<p>The problem is the body of the loop:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
cur_link = boxed_node.next.take();
#}</code></pre></pre>
<p>This is mutating the Node inside the Box, but we can't do that with Rc; it only
gives us shared access. There's two ways to handle this.</p>
<p>The first way is that we can keep grabbing the tail of the list and dropping the
previous one to decrement its count. This will prevent the old list from
recursively dropping the rest of the list because we hold an outstanding
reference to it. This has the unfortunate problem that we traverse the <em>entire</em>
list whenever we drop it. In particular this means building a list of length
n in place takes O(n<sup>2</sup>) as we traverse a lists of length <code>n-1</code>,
<code>n-2</code>, .., <code>1</code> to guard against overflow (this is really really really
really bad).</p>
<p>The second way is if we could identify that we're the last list that knows
about this node, we could in <em>principle</em> actually move the Node out of the Rc.
Then we could also know when to stop: whenever we <em>can't</em> hoist out the Node.
For reference, the function is called <code>try_unwrap</code>.</p>
<p>Rc actually lets you do this... Honestly, I'd rather
risk blowing the stack sometimes than iterate every list whenever it gets
dropped. Still if you'd rather not blow the stack, here's the first
(O(n)) solution:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        // Steal the list's head
        let mut cur_list = self.head.take();
        while let Some(node) = cur_list {
            // Clone the current node's next node.
            cur_list = node.next.clone();
            // Node dropped here. If the old node had
            // refcount 1, then it will be dropped and freed, but it won't
            // be able to fully recurse and drop its child, because we
            // hold another Rc to it.
        }
    }
}
#}</code></pre></pre>
<p>and here's the second (amortized O(1)) solution:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break;
            }
        }
    }
}
#}</code></pre></pre>
<a class="header" href="#arc" id="arc"><h1>Arc</h1></a>
<p>One reason to use an immutable linked list is to share data across threads.
After all, shared mutable state is the root of all evil, and one way to solve
that is to kill the <em>mutable</em> part forever.</p>
<p>Except our list isn't thread safe at all. In order to be thread-safe, we need
to fiddle with reference counts <em>atomically</em>. Otherwise, two threads could
try to increment the reference count, <em>and only one would happen</em>. Then the
list could get freed too soon!</p>
<p>In order to get thread safety, we have to use <em>Arc</em>. Arc is completely identical
to Rc except for the fact that reference counts are modified atomically. This
has a bit of overhead if you don't need it, so Rust exposes both.
All we need to do to make our list is replace every reference to Rc with
<code>std::sync::Arc</code>. That's it. We're thread safe. Done!</p>
<p>But this raises an interesting question: how do we <em>know</em> if a type is
thread-safe or not? Can we accidentally mess up?</p>
<p>No! You can't mess up thread-safety in Rust!</p>
<p>The reason this is the case is because Rust models thread-safety in a
first-class way with two traits: <code>Send</code> and <code>Sync</code>.</p>
<p>A type is <em>Send</em> if it's safe to <em>move</em> to another thread. A type is <em>Sync</em> if
it's safe to <em>share</em> between multiple threads. That is, if <code>T</code> is Sync, <code>&amp;T</code> is
Send. Safe in this case means it's impossible to to cause <em>data races</em>, (not to
be mistaken with the more general issue of <em>race conditions</em>).</p>
<p>These are marker traits, which is a fancy way of saying they're traits that
provide absolutely no interface. You either <em>are</em> Send, or you aren't. It's just
a property <em>other</em> APIs can require. If you aren't appropriately Send,
then it's statically impossible to be sent to a different thread! Sweet!</p>
<p>Send and Sync are also automatically derived traits based on whether you are
totally composed of Send and Sync types. It's similar to how you can only
implement Copy if you're only made of Copy types, but then we just go ahead
and implement it automatically if you are.</p>
<p>Almost every type is Send and Sync. Most types are Send because they totally
own their data. Most types are Sync because the only way to share data across
threads is to put them behind a shared reference, which makes them immutable!</p>
<p>However there are special types that violate these properties: those that have
<em>interior mutability</em>. So far we've only really interacted with <em>inherited
mutability</em> (AKA external mutability): the mutability of a value is inherited
from the mutability of its container. That is, you can't just randomly mutate
some field of a non-mutable type because you feel like it.</p>
<p>Interior mutability types violate this: they let you mutate through a shared
reference. There are two major classes of interior mutability: cells, which
only work in a single-threaded context; and locks, which work in a
multi-threaded context. For obvious reasons, cells are cheaper when you can
use them. There's also atomics, which are primitives that act like a lock.</p>
<p>So what does all of this have to do with Rc and Arc? Well, they both use
interior mutability for their <em>reference count</em>. Worse, this reference count
is shared between every instance! Rc just uses a cell, which means it's not
thread safe. Arc uses an atomic, which means it <em>is</em> thread safe. Of course,
you can't magically make a type thread safe by putting it in Arc. Arc only can
derive thread-safety like any other types.</p>
<p>I really really really don't want to get into the finer details of atomic
memory models or non-derived Send implementations. Needless to say, as you get
deeper into Rust's thread-safety story, stuff gets more complicated. As a
high-level consumer, it all <em>just works</em> and you don't really need to think
about it.</p>
<a class="header" href="#final-code-1" id="final-code-1"><h1>Final Code</h1></a>
<p>That's all I really have to say on the immutable stack. We're getting pretty
good at implementing lists now!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

pub struct Iter&lt;'a, T:'a&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}




impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn append(&amp;self, elem: T) -&gt; List&lt;T&gt; {
        List { head: Some(Rc::new(Node {
            elem: elem,
            next: self.head.clone(),
        }))}
    }

    pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
        List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
    }

    pub fn head(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| &amp;node.elem)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}



#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let list = List::new();
        assert_eq!(list.head(), None);

        let list = list.append(1).append(2).append(3);
        assert_eq!(list.head(), Some(&amp;3));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;2));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;1));

        let list = list.tail();
        assert_eq!(list.head(), None);

        // Make sure empty tail works
        let list = list.tail();
        assert_eq!(list.head(), None);

    }

    #[test]
    fn iter() {
        let list = List::new().append(1).append(2).append(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;1));
    }
}
#}</code></pre></pre>
<a class="header" href="#a-bad-but-safe-doubly-linked-deque" id="a-bad-but-safe-doubly-linked-deque"><h1>A Bad but Safe Doubly-Linked Deque</h1></a>
<p>Now that we've seen Rc and heard about interior mutability, this gives an
interesting thought... maybe we <em>can</em> mutate through an Rc. And if <em>that's</em>
the case, maybe we can implement a <em>doubly</em> linked list totally safely!</p>
<p>In the process we'll become familiar with <em>interior mutability</em>, and probably
learn the hard way that safe doesn't mean <em>correct</em>. Doubly linked lists are
hard, and I always make a mistake somewhere.</p>
<p>Let's add a new file called <code>fourth.rs</code>:</p>
<pre><code>// in lib.rs

pub mod first;
pub mod second;
pub mod third;
pub mod fourth;
</code></pre>
<p>This will be another clean-room operation, though as usual we'll probably find
some logic that applies verbatim again.</p>
<a class="header" href="#layout-1" id="layout-1"><h1>Layout</h1></a>
<p>The key to our design is the <code>RefCell</code> type. The heart of
RefCell is a pair of methods:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn borrow&lt;'a&gt;(&amp;'a self) -&gt; Ref&lt;'a, T&gt;
fn borrow_mut&lt;'a&gt;(&amp;'a self) -&gt; RefMut&lt;'a, T&gt;
#}</code></pre></pre>
<p>The rules for <code>borrow</code> and <code>borrow_mut</code> are exactly those of <code>&amp;</code> and <code>&amp;mut</code>:
you can call <code>borrow</code> as many times as you want, but <code>borrow_mut</code> requires
exclusivity.</p>
<p>Rather than enforcing this statically, RefCell enforces them at runtime.
If you break the rules, RefCell will just panic and crash the program.
Why does it return these Ref and RefMut things? Well, they basically behave
like <code>Rc</code>s but for borrowing. They keep the RefCell borrowed until they go out
of scope. We'll get to that later.</p>
<p>Now with Rc and RefCell we can become... an incredibly verbose pervasively
mutable garbage collected language that can't collect cycles! Y-yaaaaay...</p>
<p>Alright, we want to be <em>doubly linked</em>. This means each node has a pointer to
the previous and next node. Also, the list itself has a pointer to the
first and last node. This gives us fast insertion and removal on <em>both</em>
ends of the list.</p>
<p>So we probably want something like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;
use std::cell::RefCell;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
    prev: Link&lt;T&gt;,
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:5:5: 5:18 warning: struct field is never used: `head`, #[warn(dead_code)] on by default
src/fourth.rs:5     head: Link&lt;T&gt;,
                    ^~~~~~~~~~~~~
src/fourth.rs:6:5: 6:18 warning: struct field is never used: `tail`, #[warn(dead_code)] on by default
src/fourth.rs:6     tail: Link&lt;T&gt;,
                    ^~~~~~~~~~~~~
src/fourth.rs:11:1: 15:2 warning: struct is never used: `Node`, #[warn(dead_code)] on by default
src/fourth.rs:11 struct Node&lt;T&gt; {
src/fourth.rs:12     elem: T,
src/fourth.rs:13     next: Link&lt;T&gt;,
src/fourth.rs:14     prev: Link&lt;T&gt;,
src/fourth.rs:15 }
src/fourth.rs:12:5: 12:12 warning: struct field is never used: `elem`, #[warn(dead_code)] on by default
src/fourth.rs:12     elem: T,
                     ^~~~~~~
src/fourth.rs:13:5: 13:18 warning: struct field is never used: `next`, #[warn(dead_code)] on by default
src/fourth.rs:13     next: Link&lt;T&gt;,
                     ^~~~~~~~~~~~~
src/fourth.rs:14:5: 14:18 warning: struct field is never used: `prev`, #[warn(dead_code)] on by default
src/fourth.rs:14     prev: Link&lt;T&gt;,
                     ^~~~~~~~~~~~~
</code></pre>
<p>Hey, it built! Lots of dead code warnings, but it built! Let's try to use it.</p>
<a class="header" href="#building-up" id="building-up"><h1>Building Up</h1></a>
<p>Alright, we'll start with building the list. That's pretty straight-forward
with this new system. <code>new</code> is still trivial, just None out all the fields.
Also because it's getting a bit unwieldy, let's break out a Node constructor
too:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; Node&lt;T&gt; {
    fn new(elem: T) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        Rc::new(RefCell::new(Node {
            elem: elem,
            prev: None,
            next: None,
        }))
    }
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build

**A BUNCH OF DEAD CODE WARNINGS BUT IT BUILT**
</code></pre>
<p>Yay!</p>
<p>Now let's try to write pushing onto the front of the list. Because
doubly-linked lists are signficantly more complicated, we're going to need
to do a fair bit more work. Where singly-linked list operations could be
reduced to an easy one-liner, doubly-linked list ops are fairly complicated.</p>
<p>In particular we now need to specially handle some boundary cases around
empty lists. Most operations will only touch the <code>head</code> or <code>tail</code> pointer.
However when transitioning to or from the empty list, we need to edit
<em>both</em> at once.</p>
<p>An easy way for us to validate if our methods make sense is if we maintain
the following invariant: each node should have exactly two pointers to it.
Each node in the middle of the list is pointed at by its predecessor and
successor, while the nodes on the ends are pointed to by the list itself.</p>
<p>Let's take a crack at it:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn push_front(&amp;mut self, elem: T) {
    // new node needs +2 links, everything else should be +0
    let new_head = Node::new(elem);
    match self.head.take() {
        Some(old_head) =&gt; {
            // non-empty list, need to connect the old_head
            old_head.prev = Some(new_head.clone()); // +1 new_head
            new_head.next = Some(old_head);         // +1 old_head
            self.head = Some(new_head);             // +1 new_head, -1 old_head
            // total: +2 new_head, +0 old_head -- OK!
        }
        None =&gt; {
            // empty list, need to set the tail
            self.tail = Some(new_head.clone());     // +1 new_head
            self.head = Some(new_head);             // +1 new_head
            // total: +2 new_head -- OK!
        }
    }
}
#}</code></pre></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:37:17: 37:30 error: attempted access of field `prev` on type `alloc::rc::Rc&lt;core::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`, but no field with that name was found
src/fourth.rs:37                 old_head.prev = Some(new_head.clone());
                                 ^~~~~~~~~~~~~
src/fourth.rs:38:17: 38:30 error: attempted access of field `next` on type `alloc::rc::Rc&lt;core::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`, but no field with that name was found
src/fourth.rs:38                 new_head.next = Some(old_head);
                                 ^~~~~~~~~~~~~
error: aborting due to 2 previous errors
Could not compile `lists`.
</code></pre>
<p>Alright. Compiler error. Good start. Good start.</p>
<p>Why can't we access the <code>prev</code> and <code>next</code> fields on our nodes? It worked before
when we just had an <code>Rc&lt;Node&gt;</code>. Seems like the <code>RefCell</code> is getting in the way.</p>
<p>We should probably check the docs.</p>
<p><em>Google's &quot;rust refcell&quot;</em></p>
<p><em><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">clicks first link</a></em></p>
<blockquote>
<p>A mutable memory location with dynamically checked borrow rules</p>
<p>See the <a href="https://doc.rust-lang.org/std/cell/index.html">module-level documentation</a> for more.</p>
</blockquote>
<p><em>clicks link</em></p>
<blockquote>
<p>Shareable mutable containers.</p>
<p>Values of the <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> types may be mutated through shared references (i.e.
the common <code>&amp;T</code> type), whereas most Rust types can only be mutated through unique (<code>&amp;mut T</code>)
references. We say that <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> provide 'interior mutability', in contrast
with typical Rust types that exhibit 'inherited mutability'.</p>
<p>Cell types come in two flavors: <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>. <code>Cell&lt;T&gt;</code> provides <code>get</code> and <code>set</code>
methods that change the interior value with a single method call. <code>Cell&lt;T&gt;</code> though is only
compatible with types that implement <code>Copy</code>. For other types, one must use the <code>RefCell&lt;T&gt;</code>
type, acquiring a write lock before mutating.</p>
<p><code>RefCell&lt;T&gt;</code> uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can
claim temporary, exclusive, mutable access to the inner value. Borrows for <code>RefCell&lt;T&gt;</code>s are
tracked 'at runtime', unlike Rust's native reference types which are entirely tracked
statically, at compile time. Because <code>RefCell&lt;T&gt;</code> borrows are dynamic it is possible to attempt
to borrow a value that is already mutably borrowed; when this happens it results in thread
panic.</p>
<a class="header" href="#when-to-choose-interior-mutability" id="when-to-choose-interior-mutability"><h1>When to choose interior mutability</h1></a>
<p>The more common inherited mutability, where one must have unique access to mutate a value, is
one of the key language elements that enables Rust to reason strongly about pointer aliasing,
statically preventing crash bugs. Because of that, inherited mutability is preferred, and
interior mutability is something of a last resort. Since cell types enable mutation where it
would otherwise be disallowed though, there are occasions when interior mutability might be
appropriate, or even <em>must</em> be used, e.g.</p>
<ul>
<li>Introducing inherited mutability roots to shared types.</li>
<li>Implementation details of logically-immutable methods.</li>
<li>Mutating implementations of <code>Clone</code>.</li>
</ul>
<a class="header" href="#introducing-inherited-mutability-roots-to-shared-types" id="introducing-inherited-mutability-roots-to-shared-types"><h2>Introducing inherited mutability roots to shared types</h2></a>
<p>Shared smart pointer types, including <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, provide containers that can be
cloned and shared between multiple parties. Because the contained values may be
multiply-aliased, they can only be borrowed as shared references, not mutable references.
Without cells it would be impossible to mutate data inside of shared boxes at all!</p>
<p>It's very common then to put a <code>RefCell&lt;T&gt;</code> inside shared pointer types to reintroduce
mutability:</p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let shared_map: Rc&lt;RefCell&lt;_&gt;&gt; = Rc::new(RefCell::new(HashMap::new()));
    shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
    shared_map.borrow_mut().insert(&quot;kyoto&quot;, 11837);
    shared_map.borrow_mut().insert(&quot;piccadilly&quot;, 11826);
    shared_map.borrow_mut().insert(&quot;marbles&quot;, 38);
}
</code></pre></pre>
<p>Note that this example uses <code>Rc&lt;T&gt;</code> and not <code>Arc&lt;T&gt;</code>. <code>RefCell&lt;T&gt;</code>s are for single-threaded
scenarios. Consider using <code>Mutex&lt;T&gt;</code> if you need shared mutability in a multi-threaded
situation.</p>
</blockquote>
<p>Hey, Rust's docs continue to be incredibly awesome.</p>
<p>The meaty bit we care about is this line:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
#}</code></pre></pre>
<p>In particular, the <code>borrow_mut</code> thing. Seems we need to explicitly borrow a
RefCell. The <code>.</code> operator's not going to do it for us. Weird. Let's try:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn push_front(&amp;mut self, elem: T) {
    let new_head = Node::new(elem);
    match self.head.take() {
        Some(old_head) =&gt; {
            old_head.borrow_mut().prev = Some(new_head.clone());
            new_head.borrow_mut().next = Some(old_head);
            self.head = Some(new_head);
        }
        None =&gt; {
            self.tail = Some(new_head.clone());
            self.head = Some(new_head);
        }
    }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:12:5: 12:12 warning: struct field is never used: `elem`, #[warn(dead_code)] on by default
src/fourth.rs:12     elem: T,
                     ^~~~~~~
</code></pre>
<p>Hey, it built! Docs win again.</p>
<a class="header" href="#breaking-down" id="breaking-down"><h1>Breaking Down</h1></a>
<p><code>pop_front</code> should be the same basic logic as <code>push_front</code>, but backwards. Let's
try:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
    // need to take the old head, ensuring it's -2
    self.head.take().map(|old_head| {                         // -1 old
        match old_head.borrow_mut().next.take() {
            Some(new_head) =&gt; {                               // -1 new
                // not emptying list
                new_head.borrow_mut().prev.take();            // -1 old
                self.head = Some(new_head);                   // +1 new
                // total: -2 old, +0 new
            }
            None =&gt; {
                // emptying list
                self.tail.take();                             // -1 old
                // total: -2 old, (no new)
            }
        }
        old_head.elem
    })
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:63:13: 63:26 error: attempted access of field `elem` on type `alloc::rc::Rc&lt;core::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`, but no field with that name was found
src/fourth.rs:63             old_head.elem
                             ^~~~~~~~~~~~~
note: in expansion of closure expansion
src/fourth.rs:49:30: 64:10 note: expansion site
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>ACK. <em>RefCells</em>. Gotta <code>borrow_mut</code> again I guess...</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.head.take().map(|old_head| {
        match old_head.borrow_mut().next.take() {
            Some(new_head) =&gt; {
                new_head.borrow_mut().prev.take();
                self.head = Some(new_head);
            }
            None =&gt; {
                self.tail.take();
            }
        }
        old_head.borrow_mut().elem
    })
}
#}</code></pre></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:58:13: 58:34 error: cannot move out of borrowed content
src/fourth.rs:58             old_head.borrow_mut().elem
                             ^~~~~~~~~~~~~~~~~~~~~
note: in expansion of closure expansion
src/fourth.rs:48:30: 59:10 note: expansion site
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p><em>sigh</em></p>
<blockquote>
<p>cannot move out of borrowed content</p>
</blockquote>
<p>Hrm... It seems that Box was <em>really</em> spoiling us. <code>borrow_mut</code> only gets us
an <code>&amp;mut Node&lt;T&gt;</code>, but we can't move out of that!</p>
<p>We need something that takes a <code>RefCell&lt;T&gt;</code> and gives us a <code>T</code>. Let's check
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">the docs</a> for something like that:</p>
<blockquote>
<p><code>fn into_inner(self) -&gt; T</code></p>
<p>Consumes the RefCell, returning the wrapped value.</p>
</blockquote>
<p>That looks promising!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
old_head.into_inner().elem
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:58:13: 58:21 error: cannot move out of borrowed content
src/fourth.rs:58             old_head.into_inner().elem
                             ^~~~~~~~
note: in expansion of closure expansion
src/fourth.rs:48:30: 59:10 note: expansion site
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>Uh... what? Nothing changed! Dang compiler!</p>
<p>It's actually telling us the right thing, but it's not giving us quite enough
information to figure it out. So I'm just going to cut the chase: where
previously we were trying to move a <code>T</code> out of the <code>&amp;mut Node&lt;T&gt;</code>, now we're
trying to move a <code>RefCell&lt;T&gt;</code> out of an <code>&amp;RefCell&lt;T&gt;</code>. We've just pushed the
problem up the ownership chain.</p>
<p>As we saw in the previous chapter, <code>Rc&lt;T&gt;</code> only lets us get shared references
into its internals. That makes sense, because that's <em>the whole point</em> of
reference counted pointers: they're shared!</p>
<p>This was a problem for us when we wanted to implement Drop for our reference
counted list, because we needed to gain ownership of the nodes to drop them
one at a time.</p>
<p>Now we can use <code>Rc::try_unwrap</code>, which moves out the contents of an Rc out
if its refcount is 1.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Rc::try_unwrap(old_head).unwrap().into_inner().elem
#}</code></pre></pre>
<p><code>Rc::try_unwrap</code> returns a <code>Result&lt;T, Rc&lt;T&gt;&gt;</code>. Results are basically a
generalized <code>Option</code>, where the <code>None</code> case has data associated with it. In
this case, the <code>Rc</code> you tried to unwrap. Since we don't care about the case
where it fails (if we wrote our program correctly, it <em>has</em> to succeed), we
just call <code>unwrap</code> on it.</p>
<p><code>unwrap</code> is a function on Results and Options that basically says &quot;get the
the value out, or panic the program&quot;. Panics are A Whole Thing, so I'll simplify
things by just saying a panics crash your program in a controlled manner,
effectively making every function instantly return. Notably, it makes sure to
call all the destructors that happen to be laying around on the way out. So your
memory will get freed (meh? OS does that anyway, right?) and your Connections
and Files will get properly saved/closed (yay!).</p>
<p>This is a bit of a lie, there's cases where you can stop a panic. In particular
at a thread boundary if you're into that whole &quot;parallelism&quot; thing. That whole
freeing your memory thing is less lame there, <em>I guess</em>.</p>
<p>Anyway, let's see what compiler error we get next (let's face it, there's going
to be one).</p>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:58:38: 58:46 error: no method named `unwrap` found for type `core::result::Result&lt;core::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;, alloc::rc::Rc&lt;core::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;&gt;` in the current scope
src/fourth.rs:58             Rc::try_unwrap(old_head).unwrap().into_inner().elem
                                                      ^~~~~~~~
note: in expansion of closure expansion
src/fourth.rs:48:30: 59:10 note: expansion site
src/fourth.rs:58:38: 58:46 note: the method `unwrap` exists but the following trait bounds were not satisfied: `alloc::rc::Rc&lt;core::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt; : core::fmt::Debug`
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>UGH. This is dumb. Rust is dumb. <code>unwrap</code> on Result requires that you can
debug-print the error case. <code>RefCell&lt;T&gt;</code> only implements <code>Debug</code> if <code>T</code> does.
<code>Node</code> doesn't implement Debug. We could just implement Debug for Node but I'm
not in the mood. Let's just work around this by turning the <code>Result</code> into an
<code>Option</code> with the <code>ok</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem
#}</code></pre></pre>
<p>PLEASE.</p>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
</code></pre>
<p>YES.</p>
<p><em>phew</em></p>
<p>We did it.</p>
<p>We implemented <code>push</code> and <code>pop</code>.</p>
<p>Let's test by stealing the old <code>stack</code> basic test (because that's all that
we've implemented so far):</p>
<pre><code>#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop_front(), None);

        // Populate list
        list.push_front(1);
        list.push_front(2);
        list.push_front(3);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(3));
        assert_eq!(list.pop_front(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_front(4);
        list.push_front(5);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(5));
        assert_eq!(list.pop_front(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_front(), Some(1));
        assert_eq!(list.pop_front(), None);
    }
}
</code></pre>
<pre><code class="language-text">cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 9 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::basics ... ok
test fifth::test::iter_mut ... ok
test third::test::basics ... ok
test second::test::iter ... ok
test third::test::iter ... ok
test second::test::into_iter ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p><em>Nailed it</em>.</p>
<p>Now that we can properly remove things from the list, we can implement Drop.
Drop is a little more conceptually interesting this time around. Where
previously we bothered to implement Drop for our stacks just to avoid unbounded
recursion, now we need to implement Drop to get <em>anything</em> to happen at all.</p>
<p><code>Rc</code> can't deal with cycles. If there's a cycle, everything will keep everything
else alive. A doubly linked list, as it turns out, is just a big chain of tiny
cycles! So when we drop our list, the two end nodes will have their refcounts
decremented down to 1... and then nothing else will happen. Well, if our list
contains exactly one node we're good to go. But ideally a list should work right
if it contains multiple elements. Maybe that's just me.</p>
<p>As we saw, removing elements was a bit painful. So the easiest thing for us to
do is just <code>pop</code> until we get None:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        while self.pop_front().is_some() {}
    }
}
#}</code></pre></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
</code></pre>
<p>(We actually could have done this with our mutable stacks, but shortcuts are for
people who understand things!)</p>
<p>We could look at implementing the <code>_back</code> versions of <code>push</code> and <code>pop</code>, but
they're just copy-paste jobs which we'll defer to later in the chapter. For now
let's look at more interesting things!</p>
<a class="header" href="#peeking" id="peeking"><h1>Peeking</h1></a>
<p>Alright, we made it through <code>push</code> and <code>pop</code>. I'm not gonna lie, it got a
bit emotional there. Compile-time correctness is a hell of a drug.</p>
<p>Let's cool off by doing something simple: let's just implement <code>peek_front</code>.
That was always really easy before. Gotta still be easy, right?</p>
<p>Right?</p>
<p>In fact, I think I can just copy-paste it!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn peek_front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| {
        &amp;node.elem
    })
}
#}</code></pre></pre>
<p>Wait. Not this time.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn peek_front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| {
        &amp;node.borrow().elem
    })
}
#}</code></pre></pre>
<p>HAH.</p>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:64:14: 64:27 error: borrowed value does not live long enough
src/fourth.rs:64             &amp;node.borrow().elem
                              ^~~~~~~~~~~~~
note: in expansion of closure expansion
src/fourth.rs:63:32: 65:10 note: expansion site
src/fourth.rs:62:44: 66:6 note: reference must be valid for the anonymous lifetime #1 defined on the block at 62:43...
src/fourth.rs:62     pub fn peek_front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
src/fourth.rs:63         self.head.as_ref().map(|node| {
src/fourth.rs:64             &amp;node.borrow().elem
src/fourth.rs:65         })
src/fourth.rs:66     }
src/fourth.rs:63:39: 65:10 note: ...but borrowed value is only valid for the block at 63:38
src/fourth.rs:63         self.head.as_ref().map(|node| {
src/fourth.rs:64             &amp;node.borrow().elem
src/fourth.rs:65         })
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>Ok I'm just burning my computer.</p>
<p>This is exactly the same logic as our singly linked stack. Why are things
different. WHY.</p>
<p>The answer is really the whole moral of this chapter: RefCells make everything
sadness. Up until now, RefCells have just been a nuisance. Now they're going to
become a nightmare.</p>
<p>So what's going on? To understand that, we need to go back to the definition of
<code>borrow</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn borrow&lt;'a&gt;(&amp;'a self) -&gt; Ref&lt;'a, T&gt;
fn borrow_mut&lt;'a&gt;(&amp;'a self) -&gt; RefMut&lt;'a, T&gt;
#}</code></pre></pre>
<p>In the layout section we said:</p>
<blockquote>
<p>Rather than enforcing this statically, RefCell enforces them at runtime.
If you break the rules, RefCell will just panic and crash the program.
Why does it return these Ref and RefMut things? Well, they basically behave
like <code>Rc</code>s but for borrowing. They keep the RefCell borrowed until they go out
of scope. We'll get to that later.</p>
</blockquote>
<p>It's later.</p>
<p><code>Ref</code> and <code>RefMut</code> implement <code>Deref</code> and <code>DerefMut</code> respectively. So for most
intents and purposes they behave <em>exactly</em> like <code>&amp;T</code> and <code>&amp;mut T</code>. However,
because of how those traits work, the reference that's returned is connected
to the lifetime of the Ref, and not actual RefCell. This means that the Ref
has to be sitting around as long as we keep the reference around.</p>
<p>This is in fact necessary for correctness. When a Ref gets dropped, it tells
the RefCell that it's not borrowed anymore. So if we <em>did</em> manage to hold onto our
reference longer than the Ref existed, we could get a RefMut while a reference
was kicking around and totally break Rust's type system in half.</p>
<p>So where does that leave us? We only want to return a reference, but we need
to keep this Ref thing around. But as soon as we return the reference from
<code>peek</code>, the function is over and the <code>Ref</code> goes out of scope.</p>
<p>😖</p>
<p>As far as I know, we're actually totally dead in the water here. You can't
totally encapsulate the use of RefCells like that.</p>
<p>But... what if we just give up on totally hiding our implementation details?
What if we returns Refs?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        node.borrow()
    })
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:62:40: 62:46 error: use of undeclared type name `Ref` [E0412]
src/fourth.rs:62     pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
                                                        ^~~~~~
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>Blurp. Gotta import some stuff.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::{Ref, RefMut, RefCell};
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:63:9: 65:11 error: mismatched types:
 expected `core::option::Option&lt;core::cell::Ref&lt;'_, T&gt;&gt;`,
    found `core::option::Option&lt;core::cell::Ref&lt;'_, fourth::Node&lt;T&gt;&gt;&gt;`
(expected type parameter,
    found struct `fourth::Node`) [E0308]
src/fourth.rs:63         self.head.as_ref().map(|node| {
src/fourth.rs:64             node.borrow()
src/fourth.rs:65         })
src/fourth.rs:63:9: 65:11 help: run `rustc --explain E0308` to see a detailed explanation
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>Hmm... that's right. We have a <code>Ref&lt;Node&lt;T&gt;&gt;</code>, but we want a <code>Ref&lt;T&gt;</code>. We could
abandon all hope of encapsulation and just return that. We could also make
things even more complicated and wrap <code>Ref&lt;Node&lt;T&gt;&gt;</code> in a new type to only
expose access to an <code>&amp;T</code>.</p>
<p>Both of those options are <em>kinda</em> lame.</p>
<p>Instead, we're going to go deeper down. Let's
have some <em>fun</em>. Our source of fun is <em>this beast</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
map&lt;U, F&gt;(orig: Ref&lt;'b, T&gt;, f: F) -&gt; Ref&lt;'b, U&gt;
    where F: FnOnce(&amp;T) -&gt; &amp;U,
          U: ?Sized
#}</code></pre></pre>
<blockquote>
<p>Make a new Ref for a component of the borrowed data.</p>
</blockquote>
<p>Yes: just like you can map over an Option, you can map over a Ref.</p>
<p>I'm sure someone somewhere is really excited because <em>monads</em> or whatever but
I don't care about any of that. Also I don't think it's a proper monad since
there's no None-like case. But I digress.</p>
<p>It's cool and that's all that matters to me. <em>I need this</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &amp;node.elem)
    })
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:1:22: 1:28 warning: unused import, #[warn(unused_imports)] on by default
src/fourth.rs:1 use std::cell::{Ref, RefMut, RefCell};
                                     ^~~~~~
</code></pre>
<p>Awww yissss</p>
<p>Let's make sure this is working by munging up the test from our stack. We need
to do some munging to deal with the fact that Refs don't implement comparisons.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn peek() {
    let mut list = List::new();
    assert!(list.peek_front().is_none());
    list.push_front(1); list.push_front(2); list.push_front(3);

    assert_eq!(&amp;*list.peek_front().unwrap(), &amp;3);
}
#}</code></pre></pre>
<pre><code>&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:1:22: 1:28 warning: unused import, #[warn(unused_imports)] on by default
src/fourth.rs:1 use std::cell::{Ref, RefMut, RefCell};
                                     ^~~~~~
     Running target/debug/lists-5c71138492ad4b4a

running 10 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test fourth::test::peek ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test third::test::basics ... ok
test second::test::peek ... ok
test second::test::iter ... ok
test third::test::iter ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Great!</p>
<a class="header" href="#symmetric-junk" id="symmetric-junk"><h1>Symmetric Junk</h1></a>
<p>Alright let's get all that combinatoric symmtery over with.</p>
<p>All we have to do is some basic text replacement:</p>
<pre><code class="language-text">tail &lt;-&gt; head
next &lt;-&gt; prev
front -&gt; back
</code></pre>
<p>Oh, also we need to add <code>_mut</code> variants for peeking.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn push_back(&amp;mut self, elem: T) {
    let new_tail = Node::new(elem);
    match self.tail.take() {
        Some(old_tail) =&gt; {
            old_tail.borrow_mut().next = Some(new_tail.clone());
            new_tail.borrow_mut().prev = Some(old_tail);
            self.tail = Some(new_tail);
        }
        None =&gt; {
            self.head = Some(new_tail.clone());
            self.tail = Some(new_tail);
        }
    }
}

pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.tail.take().map(|old_tail| {
        match old_tail.borrow_mut().prev.take() {
            Some(new_tail) =&gt; {
                new_tail.borrow_mut().next.take();
                self.tail = Some(new_tail);
            }
            None =&gt; {
                self.head.take();
            }
        }
        Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
    })
}

pub fn peek_back(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.tail.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &amp;node.elem)
    })
}

pub fn peek_back_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
    self.tail.as_ref().map(|node| {
        RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
    })
}

pub fn peek_front_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
    })
}
#}</code></pre></pre>
<p>And massively flesh out our tests:</p>
<pre><code>#[test]
fn basics() {
    let mut list = List::new();

    // Check empty list behaves right
    assert_eq!(list.pop_front(), None);

    // Populate list
    list.push_front(1);
    list.push_front(2);
    list.push_front(3);

    // Check normal removal
    assert_eq!(list.pop_front(), Some(3));
    assert_eq!(list.pop_front(), Some(2));

    // Push some more just to make sure nothing's corrupted
    list.push_front(4);
    list.push_front(5);

    // Check normal removal
    assert_eq!(list.pop_front(), Some(5));
    assert_eq!(list.pop_front(), Some(4));

    // Check exhaustion
    assert_eq!(list.pop_front(), Some(1));
    assert_eq!(list.pop_front(), None);

    // ---- back -----

    // Check empty list behaves right
    assert_eq!(list.pop_back(), None);

    // Populate list
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);

    // Check normal removal
    assert_eq!(list.pop_back(), Some(3));
    assert_eq!(list.pop_back(), Some(2));

    // Push some more just to make sure nothing's corrupted
    list.push_back(4);
    list.push_back(5);

    // Check normal removal
    assert_eq!(list.pop_back(), Some(5));
    assert_eq!(list.pop_back(), Some(4));

    // Check exhaustion
    assert_eq!(list.pop_back(), Some(1));
    assert_eq!(list.pop_back(), None);
}

#[test]
fn peek() {
    let mut list = List::new();
    assert!(list.peek_front().is_none());
    assert!(list.peek_back().is_none());
    assert!(list.peek_front_mut().is_none());
    assert!(list.peek_back_mut().is_none());

    list.push_front(1); list.push_front(2); list.push_front(3);

    assert_eq!(&amp;*list.peek_front().unwrap(), &amp;3);
    assert_eq!(&amp;mut *list.peek_front_mut().unwrap(), &amp;mut 3);
    assert_eq!(&amp;*list.peek_back().unwrap(), &amp;1);
    assert_eq!(&amp;mut *list.peek_back_mut().unwrap(), &amp;mut 1);
}
</code></pre>
<p>Are there some cases we're not testing? Probably. The combinatoric space
has really blown up here. Our code is at very least not <em>obviously wrong</em>.</p>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 10 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test fourth::test::peek ... ok
test second::test::iter ... ok
test third::test::iter ... ok
test second::test::into_iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Nice. Copy-pasting is the best kind of programming.</p>
<a class="header" href="#iteration" id="iteration"><h1>Iteration</h1></a>
<p>Let's take a crack at iterating this bad-boy.</p>
<a class="header" href="#intoiter-1" id="intoiter-1"><h2>IntoIter</h2></a>
<p>IntoIter, as always, is going to be the easiest. Just wrap the stack and
call <code>pop</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_front()
    }
}
#}</code></pre></pre>
<p>But we have an interesting new development. Where previously there was only
ever one &quot;natural&quot; iteration order for our lists, a Deque is inherently
bi-directional. What's so special about front-to-back? What if someone wants
to iterate in the other direction?</p>
<p>Rust actually has an answer to this: <code>DoubleEndedIterator</code>. DoubleEndedIterator
<em>inherits</em> from Iterator (meaning all DoubleEndedIterator are Iterators) and
requires one new method: <code>next_back</code>. It has the exact same signature as
<code>next</code>, but it's supposed to yield elements from the other end. The semantics
of DoubleEndedIterator are super convenient for us: the iterator becomes a
deque. You can consume elements from the front and back until the two ends
converge, at which point the iterator is empty.</p>
<p>Much like Iterator and <code>next</code>, it turns out that <code>next_back</code> isn't really
something consumers of the DoubleEndedIterator really care about. Rather, the
best part of this interface is that it exposes the <code>rev</code> method, which wraps
up the iterator to make a new one that yields the elements in reverse order.
The semantics of this are fairly straight-forward: calls to <code>next</code> on the
reversed iterator are just calls to <code>next_back</code>.</p>
<p>Anyway, because we're already a deque providing this API is pretty easy:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_back()
    }
}
#}</code></pre></pre>
<p>And let's test it out:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn into_iter() {
    let mut list = List::new();
    list.push_front(1); list.push_front(2); list.push_front(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next_back(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next_back(), None);
    assert_eq!(iter.next(), None);
}
#}</code></pre></pre>
<pre><code class="language-text">cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 11 tests
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test fourth::test::into_iter ... ok
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test third::test::iter ... ok
test third::test::basics ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Nice.</p>
<a class="header" href="#iter-1" id="iter-1"><h2>Iter</h2></a>
<p>Iter will be a bit less forgiving. We'll have to deal with those awful <code>Ref</code>
things again! Because of Refs, we can't store <code>&amp;Node</code>s like we did before.
Instead, let's try to store <code>Ref&lt;Node&gt;</code>s:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Iter&lt;'a, T: 'a&gt;(Option&lt;Ref&lt;'a, Node&lt;T&gt;&gt;&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter(self.head.as_ref().map(|head| head.borrow()))
    }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
</code></pre>
<p>So far so good. Implementing <code>next</code> is going to be a bit hairy, but I think
it's the same basic logic as the old stack IterMut but with extra RefCell
madness:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = Ref&lt;'a, T&gt;;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.take().map(|node_ref| {
            self.0 = node_ref.next.as_ref().map(|head| head.borrow());
            Ref::map(node_ref, |node| &amp;node.elem)
        })
    }
}
#}</code></pre></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:154:22: 154:30 error: `node_ref` does not live long enough
src/fourth.rs:154             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
                                       ^~~~~~~~
note: in expansion of closure expansion
src/fourth.rs:153:27: 156:10 note: expansion site
src/fourth.rs:152:46: 157:6 note: reference must be valid for the lifetime 'a as defined on the block at 152:45...
src/fourth.rs:152     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
src/fourth.rs:153         self.0.take().map(|node_ref| {
src/fourth.rs:154             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
src/fourth.rs:155             Ref::map(node_ref, |node| &amp;node.elem)
src/fourth.rs:156         })
src/fourth.rs:157     }
src/fourth.rs:153:38: 156:10 note: ...but borrowed value is only valid for the scope of parameters for function at 153:37
src/fourth.rs:153         self.0.take().map(|node_ref| {
src/fourth.rs:154             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
src/fourth.rs:155             Ref::map(node_ref, |node| &amp;node.elem)
src/fourth.rs:156         })
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>Shoot.</p>
<p><code>node_ref</code> doesn't live long enough. Unlike normal references, Rust doesn't let
us just split Refs up like that. The Ref we get out of <code>head.borrow()</code> is only
allowed to live as long as <code>node_ref</code>, but we end up trashing that in our
<code>Ref::map</code> call.</p>
<p>I don't think there's anything we can do here. It's a dead end. Let's try
getting out of the RefCells. What if we store an <code>&amp;RefCell&lt;Node&gt;</code>?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Iter&lt;'a, T: 'a&gt;(Option&lt;&amp;'a RefCell&lt;Node&lt;T&gt;&gt;&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter(self.head.as_ref().map(|head| &amp;** head))
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = Ref&lt;'a, T&gt;;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.take().map(|node| {
            self.0 = node.borrow().next.as_ref().map(|head| &amp;**head);
            Ref::map(node.borrow(), |node| &amp;node.elem)
        })
    }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fourth.rs:154:22: 154:35 error: borrowed value does not live long enough
src/fourth.rs:154             self.0 = node.borrow().next.as_ref().map(|head| &amp;**head);
                                       ^~~~~~~~~~~~~
note: in expansion of closure expansion
src/fourth.rs:153:27: 156:10 note: expansion site
src/fourth.rs:152:46: 157:6 note: reference must be valid for the lifetime 'a as defined on the block at 152:45...
src/fourth.rs:152     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
src/fourth.rs:153         self.0.take().map(|node| {
src/fourth.rs:154             self.0 = node.borrow().next.as_ref().map(|head| &amp;**head);
src/fourth.rs:155             Ref::map(node.borrow(), |node| &amp;node.elem)
src/fourth.rs:156         })
src/fourth.rs:157     }
src/fourth.rs:154:13: 154:70 note: ...but borrowed value is only valid for the statement at 154:12
src/fourth.rs:154             self.0 = node.borrow().next.as_ref().map(|head| &amp;**head);
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: in expansion of closure expansion
src/fourth.rs:153:27: 156:10 note: expansion site
src/fourth.rs:154:13: 154:70 help: consider using a `let` binding to increase its lifetime
src/fourth.rs:154             self.0 = node.borrow().next.as_ref().map(|head| &amp;**head);
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: in expansion of closure expansion
src/fourth.rs:153:27: 156:10 note: expansion site
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>Hmm... no this is the same problem again. The <code>borrow</code> makes a Ref that we can't
keep alive long enough.</p>
<p>Hang on, though. We've got <code>Rc</code>s. Who said we even needed to store references?
Why can't we just Clone the whole Rc to get a nice owning handle into the middle
of the list?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Iter&lt;T&gt;(Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter(self.head.as_ref().map(|head| head.clone()))
    }
}

impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
    type Item =
#}</code></pre></pre>
<p>Uh... Wait what do we return now? <code>&amp;T</code>? <code>Ref&lt;T&gt;</code>?</p>
<p>No, none of those work... our Iter doesn't have a lifetime anymore! Both <code>&amp;T</code>
and <code>Ref&lt;T&gt;</code> require us to declare some lifetime up front before we get into
<code>next</code>. But anything we manage to get out of our Rc would be borrowing the
Iterator... brain... hurt... aaaaaahhhhhh</p>
<p>Maybe we can... map... the Rc... to get an <code>Rc&lt;T&gt;</code>? Is that a thing? Rc's docs
don't seem to have anything like that. Actually someone made <a href="https://crates.io/crates/owning_ref">a crate</a>
that lets you do that.</p>
<p>But wait, even if we do <em>that</em> then we've got an even bigger problem: the
dreaded spectre of iterator invalidation. Previously we've been totally immune
to iterator invalidation, because the Iter borrowed the list, leaving it totally
immutable. However now that our Iter is full of Rcs, it doesn't borrow the list
at all! That means people can start calling <code>push</code> and <code>pop</code> on the list while
they have an Iter!</p>
<p>Oh lord, what will that do?!</p>
<p>Well, pushing is actually fine. We've got a view into some sub-range of the
list, and the list will just grow beyond our sights. No biggie.</p>
<p>However <code>pop</code> is another story. If they're popping elements outside of our
range, it should <em>still</em> be fine. We can't see those nodes so nothing will
happen. However if they try to pop off the node we're pointing at... everything
will blow up! In particular when they go to <code>unwrap</code> the result of the
<code>try_unwrap</code>, it will actually fail, and the whole program will panic.</p>
<p>That's actually pretty cool. We can get tons of interior owning pointers into
the list and mutate it at the same time <em>and it will just work</em> until they
try to remove the nodes that we're pointing at. And even then we don't get
dangling pointers or anything, the program will deterministically panic!</p>
<p>But having to deal with iterator invalidation on top of mapping Rcs just
seems... lame. <code>Rc&lt;RefCell&gt;</code> has really truly finally failed us. Interestingly,
we've experienced an inversion of the persistent stack case. Where the
persistent stack struggled to ever reclaim ownership of the data but could get
references all day every day, our list had no problem gaining ownership, but
really struggled to loan our references.</p>
<p>Although to be fair, most of our struggles revolved around wanting to hide the
implementation details and have a decent API. We <em>could</em> do everything fine
if we wanted to just pass around Nodes all over the place.</p>
<p>Heck, we could make multiple concurrent IterMuts that were runtime checked to
not be mutable accessing the same element!</p>
<p>Really, this design is more appropriate for an internal data structure that
never makes it out to consumers of the API. Interior mutability is great for
writing safe <em>applications</em>. Not so much safe <em>libraries</em>.</p>
<p>Anyway, that's me giving up on Iter and IterMut. We could do them, but <em>ugh</em>.</p>
<a class="header" href="#final-code-2" id="final-code-2"><h1>Final Code</h1></a>
<p>Alright, so that's implementing a 100% safe doubly linked list in Rust. It
relies on some unstable standard library features, and had massive
implementation leak issues particularly surrounding acquiring internal
references.</p>
<p>It also was riddled with tons of &quot;unnecessary&quot; runtime checks for
correctness between <code>Rc</code> and <code>RefCell</code>. I put unnecessary in quotes because
they're actually necessary to guarantee the whole <em>actually being safe</em> thing.
We encountered a few places where those checks actually <em>were</em> necessary.
Doubly linked lists have a horribly tangled aliasing and ownership story!</p>
<p>Still, it's a thing we can do. Especially if we don't care about exposing
internal data structures to our consumers.</p>
<p>From here on out, we're going to be focusing on other side of this coin:
getting back all the control by making our implementation <em>unsafe</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::{Ref, RefMut, RefCell};
use std::rc::Rc;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
    prev: Link&lt;T&gt;,
}

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; Node&lt;T&gt; {
    fn new(elem: T) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        Rc::new(RefCell::new(Node {
            elem: elem,
            prev: None,
            next: None,
        }))
    }
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push_front(&amp;mut self, elem: T) {
        let new_head = Node::new(elem);
        match self.head.take() {
            Some(old_head) =&gt; {
                old_head.borrow_mut().prev = Some(new_head.clone());
                new_head.borrow_mut().next = Some(old_head);
                self.head = Some(new_head);
            }
            None =&gt; {
                self.tail = Some(new_head.clone());
                self.head = Some(new_head);
            }
        }
    }

    pub fn push_back(&amp;mut self, elem: T) {
        let new_tail = Node::new(elem);
        match self.tail.take() {
            Some(old_tail) =&gt; {
                old_tail.borrow_mut().next = Some(new_tail.clone());
                new_tail.borrow_mut().prev = Some(old_tail);
                self.tail = Some(new_tail);
            }
            None =&gt; {
                self.head = Some(new_tail.clone());
                self.tail = Some(new_tail);
            }
        }
    }

    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|old_head| {
            match old_head.borrow_mut().next.take() {
                Some(new_head) =&gt; {
                    new_head.borrow_mut().prev.take();
                    self.head = Some(new_head);
                }
                None =&gt; {
                    self.tail.take();
                }
            }
            Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem
        })
    }

    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.tail.take().map(|old_tail| {
            match old_tail.borrow_mut().prev.take() {
                Some(new_tail) =&gt; {
                    new_tail.borrow_mut().next.take();
                    self.tail = Some(new_tail);
                }
                None =&gt; {
                    self.head.take();
                }
            }
            Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
        })
    }

    pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
        self.head.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &amp;node.elem)
        })
    }

    pub fn peek_front_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
        self.head.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
        })
    }

    pub fn peek_back(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
        self.tail.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &amp;node.elem)
        })
    }

    pub fn peek_back_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
        self.tail.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        while self.pop_front().is_some() {}
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_front()
    }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_back()
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop_front(), None);

        // Populate list
        list.push_front(1);
        list.push_front(2);
        list.push_front(3);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(3));
        assert_eq!(list.pop_front(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_front(4);
        list.push_front(5);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(5));
        assert_eq!(list.pop_front(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_front(), Some(1));
        assert_eq!(list.pop_front(), None);

        // ---- back -----

        // Check empty list behaves right
        assert_eq!(list.pop_back(), None);

        // Populate list
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);

        // Check normal removal
        assert_eq!(list.pop_back(), Some(3));
        assert_eq!(list.pop_back(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_back(4);
        list.push_back(5);

        // Check normal removal
        assert_eq!(list.pop_back(), Some(5));
        assert_eq!(list.pop_back(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_back(), Some(1));
        assert_eq!(list.pop_back(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert!(list.peek_front().is_none());
        assert!(list.peek_back().is_none());
        assert!(list.peek_front_mut().is_none());
        assert!(list.peek_back_mut().is_none());

        list.push_front(1); list.push_front(2); list.push_front(3);

        assert_eq!(&amp;*list.peek_front().unwrap(), &amp;3);
        assert_eq!(&amp;mut *list.peek_front_mut().unwrap(), &amp;mut 3);
        assert_eq!(&amp;*list.peek_back().unwrap(), &amp;1);
        assert_eq!(&amp;mut *list.peek_back_mut().unwrap(), &amp;mut 1);
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push_front(1); list.push_front(2); list.push_front(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next_back(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next_back(), None);
        assert_eq!(iter.next(), None);
    }
}
#}</code></pre></pre>
<a class="header" href="#an-unsafe-singly-linked-queue" id="an-unsafe-singly-linked-queue"><h1>An Unsafe Singly-Linked Queue</h1></a>
<p>Ok that reference-counted interior mutability stuff got a little out of
control. Surely Rust doesn't really expect you to do that sort of thing
in general? Well, yes and no. Rc and Refcell can be great for handling
simple cases, but they can get unwieldy. Especially if you
want to hide that it's happening. There's gotta be a better way!</p>
<p>In this chapter we're going to roll back to singly linked lists and
implement a singly-linked queue to dip our toes into <em>raw pointers</em>
and <em>Unsafe Rust</em>.</p>
<p>Let's add a new file called <code>fifth.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// in lib.rs

pub mod first;
pub mod second;
pub mod third;
pub mod fourth;
pub mod fifth;
#}</code></pre></pre>
<p>Our code is largely going to be derived from second.rs, since a queue is
mostly an augmentation of a stack in the world of linked lists. Still, we're
going to go from scratch because there's some fundamental issues we want to
address with layout and what-not.</p>
<a class="header" href="#layout-2" id="layout-2"><h1>Layout</h1></a>
<p>So what's a singly-linked queue like? Well, when we had a singly linked stack
we pushed onto one end of the list, and then popped off the same end. The only
difference between a stack and a queue is that a queue pops off the <em>other</em>
end. So from our stack implementation we have:</p>
<pre><code class="language-text">input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)

stack push X:
[Some(ptr)] -&gt; (X, Some(ptr)) -&gt; (A, Some(ptr)) -&gt; (B, None)

stack pop:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)
</code></pre>
<p>To make a queue, we just need to decide which operation to move to the
end of the list: push, or pop? Since our list is singly-linked, we can
actually move <em>either</em> operation to the end with the same amount of effort.</p>
<p>To move <code>push</code> to the end, we just walk all the way to the <code>None</code> and set it
to Some with the new element.</p>
<pre><code class="language-text">input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)

flipped push X:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, Some(ptr)) -&gt; (X, None)
</code></pre>
<p>To move <code>pop</code> to the end, we just walk all the way to the node <em>before</em> the
None, and <code>take</code> it:</p>
<pre><code class="language-text">input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, Some(ptr)) -&gt; (X, None)

flipped pop:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)
</code></pre>
<p>We could do this today and call it quits, but that would stink! Both of these
operations walk over the <em>entire</em> list. Some would argue that such a queue
implementation is indeed a queue because it exposes the right interface. However
I believe that performance guarantees are part of the interface. I don't care
about precise asymptotic bounds, but rather &quot;fast&quot; and &quot;slow&quot;. Queues guarantee
that push and pop are fast, and walking over the whole list is definitely <em>not</em>
fast.</p>
<p>One key observation is that we're wasting a ton of work doing <em>the same thing</em>
over and over. Can we memoize this work? Why, yes! We can store a pointer to
the end of the list, and just jump straight to there!</p>
<p>It turns out that only one inversion of <code>push</code> and <code>pop</code> works with this.
Because our list is singly-linked, we can't effeciently walk <em>backwards</em> in
the list. To invert <code>pop</code> we would have to move the &quot;tail&quot; pointer backwards.
But if we instead invert <code>push</code> we only have to move the &quot;head&quot; pointer
forwards, which is easy.</p>
<p>Let's try that:</p>
<pre><pre class="playpen"><code class="language-rust">use std::mem;
# fn main() {}

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;, // NEW!
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // swap the old tail to point to the new tail
        let old_tail = mem::replace(&amp;mut self.tail, Some(new_tail));

        match old_tail {
            Some(mut old_tail) =&gt; {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
            }
            None =&gt; {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
            }
        }
    }
}
</code></pre></pre>
<p>I'm going a bit faster with the impl details now since we should be pretty
comfortable with this sort of thing. Not that you should necessarily expect
to produce this code on the first try. I'm just skipping over some of the
trial-and-error we've had to deal with before. I actually made a ton of mistakes
writing this code that I'm not showing. You can only see me leave off a <code>mut</code> or
<code>;</code> so many times before it stops being instructive. Don't worry, we'll see
plenty of <em>other</em> error messages!</p>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fifth.rs:33:38: 33:46 error: use of moved value: `new_tail` [E0382]
src/fifth.rs:33                 old_tail.next = Some(new_tail);
                                                     ^~~~~~~~
src/fifth.rs:28:58: 28:66 note: `new_tail` moved here because it has type `Box&lt;fifth::Node&lt;T&gt;&gt;`, which is non-copyable
src/fifth.rs:28         let old_tail = mem::replace(&amp;mut self.tail, Some(new_tail));
                                                                         ^~~~~~~~
src/fifth.rs:37:34: 37:42 error: use of moved value: `new_tail` [E0382]
src/fifth.rs:37                 self.head = Some(new_tail);
                                                 ^~~~~~~~
src/fifth.rs:28:58: 28:66 note: `new_tail` moved here because it has type `Box&lt;fifth::Node&lt;T&gt;&gt;`, which is non-copyable
src/fifth.rs:28         let old_tail = mem::replace(&amp;mut self.tail, Some(new_tail));
                                                                         ^~~~~~~~
error: aborting due to 2 previous errors
Could not compile `lists`.
</code></pre>
<p>Shoot!</p>
<blockquote>
<p>use of moved value: <code>new_tail</code></p>
</blockquote>
<p>Box doesn't implement Copy, so we can't just assign it to two locations. More
importantly, Box <em>owns</em> the thing it points to, and will try to free it when
it's dropped. If our <code>push</code> implementation compiled, we'd double-free the tail
of our list! Actually, as written, our code would free the old_tail on every
push. Yikes! 🙀</p>
<p>Alright, well we know how to make a non-owning pointer. That's just a reference!</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Option&lt;&amp;mut Node&lt;T&gt;&gt;, // NEW!
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        let new_tail = match self.tail.take() {
            Some(old_tail) =&gt; {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
                old_tail.next.as_mut().map(|node| &amp;mut **node)
            }
            None =&gt; {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
                self.head.as_mut().map(|node| &amp;mut **node)
            }
        };

        self.tail = new_tail;
    }
}
</code></pre></pre>
<p>Nothing too tricky here. Same basic idea as the previous code, except we're
using some of that implicit return goodness to extract the tail reference from
wherever we stuff the actual Box.</p>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fifth.rs:3:18: 3:30 error: missing lifetime specifier [E0106]
src/fifth.rs:3     tail: Option&lt;&amp;mut Node&lt;T&gt;&gt;, // NEW!
                                ^~~~~~~~~~~~
src/fifth.rs:3:18: 3:30 help: run `rustc --explain E0106` to see a detailed explanation
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>Oh right, we need to give references in types lifetimes. Hmm... what's the
lifetime of this reference? Well, this seems like IterMut, right? Let's try
what we did for IterMut, and just add a generic <code>'a</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
pub struct List&lt;'a, T: 'a&gt; {
    head: Link&lt;T&gt;,
    tail: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;, // NEW!
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;'a, T&gt; List&lt;'a, T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        let new_tail = match self.tail.take() {
            Some(old_tail) =&gt; {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
                old_tail.next.as_mut().map(|node| &amp;mut **node)
            }
            None =&gt; {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
                self.head.as_mut().map(|node| &amp;mut **node)
            }
        };

        self.tail = new_tail;
    }
}
</code></pre></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fifth.rs:35:27: 35:35 error: cannot infer an appropriate lifetime for autoref due to conflicting requirements
src/fifth.rs:35                 self.head.as_mut().map(|node| &amp;mut **node)
                                          ^~~~~~~~
src/fifth.rs:18:5: 40:6 help: consider using an explicit lifetime parameter as shown: fn push(&amp;'a mut self, elem: T)
src/fifth.rs:18     pub fn push(&amp;mut self, elem: T) {
src/fifth.rs:19         let new_tail = Box::new(Node {
src/fifth.rs:20             elem: elem,
src/fifth.rs:21             // When you push onto the tail, your next is always None
src/fifth.rs:22             next: None,
src/fifth.rs:23         });
                ...
error: aborting due to previous error
</code></pre>
<p>Oh lord. When the compiler starts telling us to just start adding lifetimes in
random places, it's a red flag that the compiler is deeply confused. But uh...
ok let's try that I guess?</p>
<pre><code class="language-rust ignore">    pub fn push(&amp;'a mut self, elem: T) {
</code></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fifth.rs:9:5: 9:12 warning: struct field is never used: `elem`, #[warn(dead_code)] on by default
src/fifth.rs:9     elem: T,
                   ^~~~~~~
</code></pre>
<p>Oh, hey, that worked! Great!</p>
<p>Let's just do <code>pop</code> too:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop(&amp;'a mut self) -&gt; Option&lt;T&gt; {
    // Grab the list's current head
    self.head.take().map(|head| {
        let head = *head;
        self.head = head.next;

        // If we're out of `head`, make sure to set the tail to `None`.
        if self.head.is_none() {
            self.tail = None;
        }

        head.elem
    })
}
#}</code></pre></pre>
<p>Let's try to just write a quick test for that:</p>
<pre><code>mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);
    }
}
</code></pre>
<pre><code class="language-text">cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fifth.rs:68:9: 68:13 error: cannot borrow `list` as mutable more than once at a time
src/fifth.rs:68         list.push(2);
                        ^~~~
src/fifth.rs:66:9: 66:13 note: previous borrow of `list` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `list` until the borrow ends
src/fifth.rs:66         list.push(1);
                        ^~~~
src/fifth.rs:70:6: 70:6 note: previous borrow ends here
src/fifth.rs:59     fn basics() {
...
src/fifth.rs:70     }
                    ^


**NOT SHOWN: LITERALLY A THOUSAND LINES OF BORROW CHECK ERRORS**


src/fifth.rs:84:20: 84:24 error: cannot borrow `list` as mutable more than once at a time
src/fifth.rs:84         assert_eq!(list.pop(), None);
                                   ^~~~
&lt;std macros&gt;:1:1: 9:39 note: in expansion of assert_eq!
src/fifth.rs:84:9: 84:38 note: expansion site
src/fifth.rs:83:20: 83:24 note: previous borrow of `list` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `list` until the borrow ends
src/fifth.rs:83         assert_eq!(list.pop(), Some(1));
                                   ^~~~
&lt;std macros&gt;:1:1: 9:39 note: in expansion of assert_eq!
src/fifth.rs:83:9: 83:41 note: expansion site
src/fifth.rs:85:6: 85:6 note: previous borrow ends here
src/fifth.rs:59     fn basics() {
...
src/fifth.rs:85     }
                    ^
error: aborting due to 66 previous errors
</code></pre>
<p>🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀</p>
<p>OH MY GEEZ WHAT.</p>
<p>66 borrow check errors.</p>
<p>Oh my goodness.</p>
<p><a href="https://github.com/rust-lang/rust/issues/27485">I'm pretty sure we just hit this bug in the compiler</a>.</p>
<p>But the compiler's not wrong for vomiting all over us. We just committed a
cardinal Rust sin: we stored a reference to ourselves <em>inside ourselves</em>.
Somehow, we managed to convince Rust that this totally made sense in our
<code>push</code> and <code>pop</code> implementations (I was legitimately shocked we did). I believe
the reason is that Rust can't yet tell that the reference is into ourselves
from just <code>push</code> and <code>pop</code> -- or rather, Rust doesn't really have that notion
at all. Reference-into-yourself falls over as an emergent behaviour.</p>
<p>However as soon as we tried to <em>use</em> our list, everything quickly fell apart.
When we call <code>push</code> or <code>pop</code>, we promptly store a reference to ourselves in
ourselves and become <em>trapped</em>. We are literally borrowing ourselves.</p>
<p>Our <code>pop</code> implementation hints at why this could be really dangerous:</p>
<pre><code class="language-rust ignore">// ...
if self.head.is_none() {
    self.tail = None;
}
</code></pre>
<p>What if we forgot to do this? Then our tail would point to some node <em>that
had been removed from the list</em>. Such a node would be instantly freed, and we'd
have a dangling pointer which Rust was supposed to protect us from!</p>
<p>And indeed Rust is protecting us from that kind of danger. Just in a very...
<strong>roundabout</strong> way.</p>
<p>So what can we do? Go back to <code>Rc&lt;RefCell&gt;&gt;</code> hell?</p>
<p>Please. No.</p>
<p>No instead we're going to go off the rails and use <em>raw pointers</em>.
Our layout is going to look like this:</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: *mut Node&lt;T&gt;, // DANGER DANGER
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre></pre>
<p>And that's that. None of this wimpy reference-counted-dynamic-borrow-checking
nonsense! Real. Hard. Unchecked. Pointers.</p>
<p>Let's be C everyone. Let's be C all day.</p>
<p>I'm home. I'm ready.</p>
<p>Hello <code>unsafe</code>.</p>
<a class="header" href="#unsafe-rust" id="unsafe-rust"><h1>Unsafe Rust</h1></a>
<p>This is a serious, big, complicated, and dangerous topic.
It's so serious that I wrote <a href="https://doc.rust-lang.org/nightly/nomicon/">an entire other book</a> on it.</p>
<p>The long and the short of it is that <em>every</em> language is actually unsafe as soon
as you allow calling into other languages, because you can just have C do
arbitrarily bad things. Yes: Java, Python, Ruby, Haskell... everyone is wildly
unsafe in the face of Foreign Function Interfaces (FFI).</p>
<p>Rust embraces this truth by splitting itself into two languages: Safe Rust, and
Unsafe Rust. So far we've only worked with Safe Rust. It's completely 100%
safe... except that it can FFI into Unsafe Rust.</p>
<p>Unsafe Rust is a <em>superset</em> of Safe Rust. It's completely the same as Safe Rust in all its
semantics and rules, you're just allowed to do a few <em>extra</em> things that are
wildly unsafe and can cause the dreaded Undefined Behaviour that haunts C.</p>
<p>Again, this is a really huge topic that has a lot of interesting corner cases.
I <em>really</em> don't want to go really deep into it (well, I do. I did. <a href="https://doc.rust-lang.org/nightly/nomicon/">Read that
book</a>). That's ok, because with linked lists we can actually ignore almost
all of it.</p>
<p>The main Unsafe tool we'll be using are <em>raw pointers</em>. Raw pointers are
basically C's pointers. They have no inherent aliasing rules. They have no
lifetimes. They can be null. They can be dangling. They can point to
uninitialized memory. They can be cast to and from integers. They can be cast
to point to a different type. Mutability? Cast it. Pretty much everything goes,
and that means pretty much anything can go wrong.</p>
<p>This is some bad stuff and honestly you'll live a happier life never having
to touch these. Unfortunately, we want to write linked lists, and linked lists
are awful. That means we're going to have to use unsafe pointers.</p>
<p>There are two kinds of raw pointer: <code>*const T</code> and <code>*mut T</code>. These are meant to
be <code>const T*</code> and <code>T*</code> from C, but we really don't care about what C thinks they
mean that much. You can only dereference a <code>*const T</code> to an <code>&amp;T</code>, but much like
the mutability of a variable, this is just a lint against incorrect usage. At
most it just means you have to cast the <code>*const</code> to a <code>*mut</code> first. Although if
you don't actually have permission to mutate the referrent of the pointer,
you're gonna have a bad time.</p>
<p>Anyway, we'll get a better feel for this as we write some code. For now,
<code>*mut T == &amp;unchecked mut T</code>!</p>
<a class="header" href="#basics-1" id="basics-1"><h1>Basics</h1></a>
<p>Alright, back to basics. How do we construct our list?</p>
<p>Before we just did:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }
}
#}</code></pre></pre>
<p>But we're not using Option for the <code>tail</code> anymore:</p>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fifth.rs:15:34: 15:38 error: mismatched types:
 expected `*mut fifth::Node&lt;_&gt;`,
    found `core::option::Option&lt;_&gt;`
(expected *-ptr,
    found enum `core::option::Option`) [E0308]
src/fifth.rs:15         List { head: None, tail: None }
                                                 ^~~~
src/fifth.rs:15:34: 15:38 help: run `rustc --explain E0308` to see a detailed explanation
error: aborting due to previous error
</code></pre>
<p>We <em>could</em> use an Option, but unlike Box, <code>*mut</code> <em>is</em> nullable. This means it
can't benefit from the null pointer optimization. Instead, we'll be using <code>null</code>
to represent None.</p>
<p>So how do we get a null pointer? There's a few ways, but I prefer to use
<code>std::ptr::null_mut()</code>. If you want, you can also use <code>0 as *mut _</code>, but that
just seems so <em>messy</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ptr;

// defns...

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: ptr::null_mut() }
    }
}
#}</code></pre></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fifth.rs:4:5: 4:18 warning: struct field is never used: `head`, #[warn(dead_code)] on by default
src/fifth.rs:4     head: Link&lt;T&gt;,
                   ^~~~~~~~~~~~~
src/fifth.rs:5:5: 5:23 warning: struct field is never used: `tail`, #[warn(dead_code)] on by default
src/fifth.rs:5     tail: *mut Node&lt;T&gt;,
                   ^~~~~~~~~~~~~~~~~~
src/fifth.rs:11:5: 11:12 warning: struct field is never used: `elem`, #[warn(dead_code)] on by default
src/fifth.rs:11     elem: T,
                    ^~~~~~~
src/fifth.rs:12:5: 12:18 warning: struct field is never used: `next`, #[warn(dead_code)] on by default
src/fifth.rs:12     next: Link&lt;T&gt;,
                    ^~~~~~~~~~~~~
</code></pre>
<p><em>shush</em> compiler, I will use them soon.</p>
<p>Alright, let's move on to writing <code>push</code> again. This time, instead of grabbing
an <code>Option&lt;&amp;mut Node&lt;T&gt;&gt;</code> after we insert, we're just going to grab a
<code>*mut Node&lt;T&gt;</code> to the insides of the Box right away. We know we can soundly do
this because the contents of a Box has a stable address, even if we move the
Box around. Of course, this isn't <em>safe</em>, because if we just drop the Box we'll
have a pointer to freed memory.</p>
<p>How do we make a raw pointer from a normal pointer? Coercions! If a variable
is declared to be a raw pointer, a normal reference will coerce into it:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let raw_tail: *mut _ = &amp;mut *new_tail;
#}</code></pre></pre>
<p>We have all the info we need. We can translate our code into, approximately,
the previous reference version:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn push(&amp;mut self, elem: T) {
    let mut new_tail = Box::new(Node {
        elem: elem,
        next: None,
    });

    let raw_tail: *mut _ = &amp;mut *new_tail;

    // .is_null checks for null, equivalent to checking for None
    if !self.tail.is_null() {
        // If the old tail existed, update it to point to the new tail
        self.tail.next = Some(new_tail);
    } else {
        // Otherwise, update the head to point to it
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fifth.rs:32:13: 32:27 error: attempted access of field `next` on type `*mut fifth::Node&lt;T&gt;`, but no field with that name was found
src/fifth.rs:32             self.tail.next = Some(new_tail);
                            ^~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>Huh? We have a pointer to a Node, why can't we get the <code>next</code> field?</p>
<p>Rust is kinda a jerk when you use raw pointers. To access the contents of a
raw pointer, it insists that we manually deref them, because it's such an unsafe
operation. So let's do that:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
*self.tail.next = Some(new_tail);
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fifth.rs:31:14: 31:28 error: attempted access of field `next` on type `*mut fifth::Node&lt;T&gt;`, but no field with that name was found
src/fifth.rs:31             *self.tail.next = Some(new_tail);
                             ^~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>Uuuugh operator precedence.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
(*self.tail).next = Some(new_tail);
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fifth.rs:31:14: 31:24 error: dereference of raw pointer requires unsafe function or block [E0133]
src/fifth.rs:31             (*self.tail).next = Some(new_tail);
                             ^~~~~~~~~~
src/fifth.rs:31:14: 31:24 help: run `rustc --explain E0133` to see a detailed explanation
error: aborting due to previous error
Could not compile `lists`.
</code></pre>
<p>THIS SHOULDN'T BE THIS HARD.</p>
<p>Remember how I said Unsafe Rust is like an FFI language for Safe Rust? Well, the
compiler wants us to explicitly delimit where we're doing this FFI-ing. We have
two options. First, we can mark our <em>entire</em> function as unsafe, in which case
it becomes an Unsafe Rust function and can only be called in an <code>unsafe</code>
context. This isn't great, because we want our list to be safe to use. Second,
we can write an <code>unsafe</code> block inside our function, to delimit the FFI boundary.
This declares the overall function to be safe. Let's do that one:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn push(&amp;mut self, elem: T) {
    let mut new_tail = Box::new(Node {
        elem: elem,
        next: None,
    });

    let raw_tail: *mut _ = &amp;mut *new_tail;

    // Put the box in the right place, and then grab a reference to its Node
    if !self.tail.is_null() {
        // If the old tail existed, update it to point to the new tail
        unsafe {
            (*self.tail).next = Some(new_tail);
        }
    } else {
        // Otherwise, update the head to point to it
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
src/fifth.rs:11:5: 11:12 warning: struct field is never used: `elem`, #[warn(dead_code)] on by default
src/fifth.rs:11     elem: T,
                    ^~~~~~~
</code></pre>
<p>Yay!</p>
<p>It's kind've interesting that that's the <em>only</em> place we've had to write an
unsafe block so far. We do raw pointer stuff all over the place, what's up with
that?</p>
<p>It turns out that Rust is a massive rules-lawyer pedant when it comes to
<code>unsafe</code>. We quite reasonably want to maximize the set of Safe Rust programs,
because those are programs we can be much more confident in. To accomplish this,
Rust carefully carves out a minimal surface area for unsafety. Note that all
the other places we've worked with raw pointers has been <em>assigning</em> them, or
just observing whether they're null or not.</p>
<p>If you never actually dereference a raw pointer <em>those are totally safe things
to do</em>. You're just reading and writing an integer! The only time you can
actually get into trouble with a raw pointer is if you actually dereference it.
So Rust says <em>only</em> that operation is unsafe, and everything else is totally
safe.</p>
<p>Super. Pedantic. But technically correct.</p>
<p>However this raises an interesting problem: although we're supposed to delimit
the scope of the unsafety with the <code>unsafe</code> block, it actually depends on
state that was established outside of the block. Outside of the function, even!</p>
<p>This is what I call unsafe <em>taint</em>. As soon as you use <code>unsafe</code> in a module,
that whole module is tainted with unsafety. Everything has to be correctly
written in order to make sure that invariants are upheld for the unsafe code.</p>
<p>This taint is manageable because of <em>privacy</em>. Outside of our module, all of our
struct fields are totally private, so no one else can mess with our state in
arbitrary ways. As long as no combination of the APIs we expose causes bad stuff
to happen, as far as an outside observer is concerned, all of our code is safe!
And really, this is no different from the FFI case. No one needs care
if some python math library shells out to C as long as it exposes a safe
interface.</p>
<p>Anyway, let's move on to <code>pop</code>, which is pretty much verbatim the reference
version:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.head.take().map(|head| {
        let head = *head;
        self.head = head.next;

        if self.head.is_none() {
            self.tail = ptr::null_mut();
        }

        head.elem
    })
}
#}</code></pre></pre>
<p>Again we see another case where safety is stateful. If we fail to null out the
tail pointer in <em>this</em> function, we'll see no problems at all. However
subsequent calls to <code>push</code> will start writing to the dangling tail!</p>
<p>Let's test it out:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }
}
#}</code></pre></pre>
<p>This is just the stack test, but with the expected <code>pop</code> results flipped around.
I also added some extra steps and the end to make sure that tail-pointer
corruption case in <code>pop</code> doesn't occur.</p>
<pre><code class="language-text">cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 8 tests
test first::test::basics ... ok
test second::test::basics ... ok
test fifth::test::basics ... ok
test second::test::iter ... ok
test third::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test third::test::basics ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Gold Star!</p>
<a class="header" href="#extra-junk" id="extra-junk"><h1>Extra Junk</h1></a>
<p>Now that <code>push</code> and <code>pop</code> are written, everything else is exactly the same
as the stack case. Only operations that change the length of the list need
to actually worry about the tail pointer.</p>
<p>So let's just steal all that from our second list (be sure to reverse the
expected test output):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ...

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

pub struct Iter&lt;'a, T:'a&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

pub struct IterMut&lt;'a, T: 'a&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}




impl&lt;T&gt; List&lt;T&gt; {
    // ...

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.take().map(|node| {
            self.next = node.next.as_mut().map(|node| &amp;mut **node);
            &amp;mut node.elem
        })
    }
}





#[cfg(test)]
mod test {
    // ...

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;1));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&amp;mut 1));
        assert_eq!(iter.next(), Some(&amp;mut 2));
        assert_eq!(iter.next(), Some(&amp;mut 3));
        assert_eq!(iter.next(), None);
    }
}

#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 11 tests
test fifth::test::basics ... ok
test fifth::test::iter_mut ... ok
test fifth::test::into_iter ... ok
test first::test::basics ... ok
test fifth::test::iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>Shout-outs to copy-paste programming.</p>
<p>At first I thought we'd have to mess around with IntoIter, but we still
conveniently pop in iteration order!</p>
<a class="header" href="#final-code-3" id="final-code-3"><h1>Final Code</h1></a>
<p>Alright, so with a teeny-tiny dash of unsafety we managed to get a linear
time improvement over the naive safe queue, and we managed to reuse almost
all of the logic from the safe stack!</p>
<p>We also notably <em>didn't</em> have to write any crazy Rc or RefCell stuff.</p>
<pre><pre class="playpen"><code class="language-rust">#fn main() {}
use std::ptr;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: *mut Node&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

pub struct Iter&lt;'a, T:'a&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

pub struct IterMut&lt;'a, T: 'a&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}






impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: ptr::null_mut() }
    }

    pub fn push(&amp;mut self, elem: T) {
        let mut new_tail = Box::new(Node {
            elem: elem,
            next: None,
        });

        let raw_tail: *mut _ = &amp;mut *new_tail;

        if !self.tail.is_null() {
            unsafe {
                (*self.tail).next = Some(new_tail);
            }
        } else {
            self.head = Some(new_tail);
        }

        self.tail = raw_tail;
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|head| {
            let head = *head;
            self.head = head.next;

            if self.head.is_none() {
                self.tail = ptr::null_mut();
            }

            head.elem
        })
    }

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.take().map(|node| {
            self.next = node.next.as_mut().map(|node| &amp;mut **node);
            &amp;mut node.elem
        })
    }
}



#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;1));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&amp;mut 1));
        assert_eq!(iter.next(), Some(&amp;mut 2));
        assert_eq!(iter.next(), Some(&amp;mut 3));
        assert_eq!(iter.next(), None);
    }
}
</code></pre></pre>
<a class="header" href="#an-ok-unsafe-doubly-linked-deque" id="an-ok-unsafe-doubly-linked-deque"><h1>An Ok Unsafe Doubly-Linked Deque</h1></a>
<p>Coming Soon!</p>
<a class="header" href="#a-bunch-of-silly-lists" id="a-bunch-of-silly-lists"><h1>A Bunch of Silly Lists</h1></a>
<p>Alright. That's it. We made all the lists.</p>
<p>ahahahaha</p>
<p>No</p>
<p>There's always more lists.</p>
<p>This chapter is a living document of the more ridiculous linked lists and how
they interact with Rust.</p>
<ol>
<li><a href="infinity-double-single.html">The Double Single</a></li>
<li>TODO: BList?</li>
<li>TODO: SkipList?</li>
<li>TODO: std::channel? -- That's like another whole chapter. Or 3.</li>
</ol>
<a class="header" href="#the-double-singly-linked-list" id="the-double-singly-linked-list"><h1>The Double Singly-Linked List</h1></a>
<p>We struggled with doubly linked lists because they have tangled ownership
semantics: no node strictly owns any other node. However we struggled
with this because we brought in our preconceived notions of what a linked
list <em>is</em>. Namely, we assumed that all the links go in the same direction.</p>
<p>Instead, we can smash our list into two halves: one going to the left,
and one going to the right:</p>
<pre><code>// lib.rs
// ...
pub mod silly1;     // NEW!
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// silly1.rs
use second::List as Stack;

struct List&lt;T&gt; {
    left: Stack&lt;T&gt;,
    right: Stack&lt;T&gt;,
}
#}</code></pre></pre>
<p>Now, rather than having a mere safe stack, we have a general purpose list.
We can grow the list leftwards or rightwards by pushing onto either stack.
We can also &quot;walk&quot; along the list by popping values off one end and onto the
other. To avoid needless allocations, we're going to copy the source of
our safe Stack to get access to its private details:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Stack&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; Stack&lt;T&gt; {
    pub fn new() -&gt; Self {
        Stack { head: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            let node = *node;
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }
}

impl&lt;T&gt; Drop for Stack&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
#}</code></pre></pre>
<p>And just rework <code>push</code> and <code>pop</code> a bit:</p>
<pre><code>pub fn push(&amp;mut self, elem: T) {
    let new_node = Box::new(Node {
        elem: elem,
        next: None,
    });

    self.push_node(new_node);
}

fn push_node(&amp;mut self, mut node: Box&lt;Node&lt;T&gt;&gt;) {
    node.next = self.head.take();
    self.head = Some(node);
}

pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.pop_node().map(|node| {
        node.elem
    })
}

fn pop_node(&amp;mut self) -&gt; Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt; {
    self.head.take().map(|mut node| {
        self.head = node.next.take();
        node
    })
}
</code></pre>
<p>Now we can make our List:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct List&lt;T&gt; {
    left: Stack&lt;T&gt;,
    right: Stack&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    fn new() -&gt; Self {
        List { left: Stack::new(), right: Stack::new() }
    }
}
#}</code></pre></pre>
<p>And we can do the usual stuff:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn push_left(&amp;mut self, elem: T) { self.left.push(elem) }
pub fn push_right(&amp;mut self, elem: T) { self.right.push(elem) }
pub fn pop_left(&amp;mut self) -&gt; Option&lt;T&gt; { self.left.pop() }
pub fn pop_right(&amp;mut self) -&gt; Option&lt;T&gt; { self.right.pop() }
pub fn peek_left(&amp;self) -&gt; Option&lt;&amp;T&gt; { self.left.peek() }
pub fn peek_right(&amp;self) -&gt; Option&lt;&amp;T&gt; { self.right.peek() }
pub fn peek_left_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; { self.left.peek_mut() }
pub fn peek_right_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; { self.right.peek_mut() }
#}</code></pre></pre>
<p>But most interestingly, we can walk around!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn go_left(&amp;mut self) -&gt; bool {
    self.left.pop_node().map(|node| {
        self.right.push_node(node);
    }).is_some()
}

pub fn go_right(&amp;mut self) -&gt; bool {
    self.right.pop_node().map(|node| {
        self.left.push_node(node);
    }).is_some()
}
#}</code></pre></pre>
<p>We return booleans here as just a convenience to indicate whether we actually
managed to move. Now let's test this baby out:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn walk_aboot() {
        let mut list = List::new();             // [_]

        list.push_left(0);                      // [0,_]
        list.push_right(1);                     // [0, _, 1]
        assert_eq!(list.peek_left(), Some(&amp;0));
        assert_eq!(list.peek_right(), Some(&amp;1));

        list.push_left(2);                      // [0, 2, _, 1]
        list.push_left(3);                      // [0, 2, 3, _, 1]
        list.push_right(4);                     // [0, 2, 3, _, 4, 1]

        while list.go_left() {}                 // [_, 0, 2, 3, 4, 1]

        assert_eq!(list.pop_left(), None);
        assert_eq!(list.pop_right(), Some(0));  // [_, 2, 3, 4, 1]
        assert_eq!(list.pop_right(), Some(2));  // [_, 3, 4, 1]

        list.push_left(5);                      // [5, _, 3, 4, 1]
        assert_eq!(list.pop_right(), Some(3));  // [5, _, 4, 1]
        assert_eq!(list.pop_left(), Some(5));   // [_, 4, 1]
        assert_eq!(list.pop_right(), Some(4));  // [_, 1]
        assert_eq!(list.pop_right(), Some(1));  // [_]

        assert_eq!(list.pop_right(), None);
        assert_eq!(list.pop_left(), None);

    }
}
#}</code></pre></pre>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (file:///Users/ABeingessner/dev/too-many-lists/lists)
     Running target/debug/lists-5c71138492ad4b4a

running 16 tests
test fifth::test::into_iter ... ok
test fifth::test::basics ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fourth::test::into_iter ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test first::test::basics ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test third::test::basics ... ok
test third::test::iter ... ok
test second::test::peek ... ok
test silly1::test::walk_aboot ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests lists

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>This is an extreme example of a <em>finger</em> data structure, where we maintain
some kind of finger into the structure, and as a consequence can support
operations on locations in time proportional to the distance from the finger.</p>
<p>We can make very fast changes to the list around our finger, but if we want
to make changes far away from our finger we have to walk all the way over there.
We can permanently walk over there by shifting the elements from one stack to
the other, or we could just walk along the links with an <code>&amp;mut</code>
temporarily to do the changes. However the <code>&amp;mut</code> can never go back up the
list, while our finger can!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
